#!/bin/bash

# Parse command line arguments
offline=false
COMPONENT_TYPE="POS"
base_url="test.cse.cloud4retail.co"
storeId=""       # Optional: Override Store ID detection
workstationId=""  # Optional: Override Workstation ID detection
use_default_versions=@USE_DEFAULT_VERSIONS@
version_source="@VERSION_SOURCE@"  # FP or CONFIG

# Multi-environment support parameters
env_alias=""         # -e, --env, --environment
list_environments=false  # --list-environments

# Process command line options
while [ $# -gt 0 ]; do
  case "$1" in
    --offline)
      offline=true
      shift
      ;;
    --ComponentType)
      COMPONENT_TYPE="$2"
      shift 2
      ;;
    --base_url)
      base_url="$2"
      shift 2
      ;;
    --storeId|--StoreID)
      storeId="$2"
      shift 2
      ;;
    --workstationId|--WorkstationID)
      workstationId="$2"
      shift 2
      ;;
    --UseDefaultVersions)
      use_default_versions=true
      shift
      ;;
    -e|--env|--environment)
      env_alias="$2"
      shift 2
      ;;
    --list-environments)
      list_environments=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--offline] [--ComponentType <POS|WDM|FLOW-SERVICE|LPA|SH|LPA-SERVICE|STOREHUB-SERVICE>] [--base_url <url>] [--storeId|--StoreID <id>] [--workstationId|--WorkstationID <id>] [--UseDefaultVersions] [-e|--env|--environment <alias>] [--list-environments]"
      exit 1
      ;;
  esac
done

# Validate ComponentType
valid_types=("POS" "WDM" "FLOW-SERVICE" "LPA" "SH" "LPA-SERVICE" "STOREHUB-SERVICE")
valid=false
for type in "${valid_types[@]}"; do
  if [ "$COMPONENT_TYPE" = "$type" ]; then
    valid=true
    break
  fi
done

if [ "$valid" = false ]; then
  echo "Error: Invalid ComponentType. Must be one of: ${valid_types[*]}"
  exit 1
fi

# Map shortened component types to full names
if [ "$COMPONENT_TYPE" = "LPA" ]; then
  COMPONENT_TYPE="LPA-SERVICE"
elif [ "$COMPONENT_TYPE" = "SH" ]; then
  COMPONENT_TYPE="STOREHUB-SERVICE"
fi

# Clean up any stale access token from previous runs
token_path="$PWD/helper/tokens/access_token.txt"
if [ -f "$token_path" ]; then
    rm -f "$token_path" && \
        echo "Cleaned up stale access token from previous installation" || \
        echo "Warning: Could not remove stale access token"
fi

# Clean up environment-specific username file to prevent contamination
form_username_path="$PWD/helper/tokens/form_username.txt"
if [ -f "$form_username_path" ]; then
    rm -f "$form_username_path" && \
        echo "Cleaned up stale form username from previous installation" || \
        echo "Warning: Could not remove stale form username"
fi

# Now that COMPONENT_TYPE is correctly set, capture all console output to a log file
timestamp=$(date +"%Y%m%d_%H%M%S")
log_file="GKInstall_${COMPONENT_TYPE}_$timestamp.log"
exec > >(tee -a "$log_file") 2>&1

echo "Console output is being saved to $log_file"

# Stop on first error
set -e

# Function for error handling
handle_error() {
  local line_number=$1
  echo "Error occurred at line $line_number"
  exit 1
}
trap 'handle_error $LINENO' ERR

# ============================================================================
# MULTI-ENVIRONMENT SUPPORT FUNCTIONS
# ============================================================================

# Check if jq is available
JQ_AVAILABLE=false
if command -v jq >/dev/null 2>&1; then
  JQ_AVAILABLE=true
  echo "jq detected - using for JSON parsing" >&2
else
  echo "jq not found - using fallback bash JSON parsing" >&2
fi

# Fallback function to extract JSON value (simple grep/sed approach)
# Usage: json_extract "json_string" "key"
json_extract() {
  local json="$1"
  local key="$2"
  echo "$json" | grep -o "\"$key\"[[:space:]]*:[[:space:]]*\"[^\"]*\"" | sed "s/\"$key\"[[:space:]]*:[[:space:]]*\"\([^\"]*\)\"/\1/"
}

# Fallback function to extract all environments and format them
# Usage: json_list_environments "json_string"
json_list_environments() {
  local json="$1"
  # Extract each environment block (simplified - assumes well-formed JSON)
  local env_count=0
  while IFS= read -r line; do
    if [[ "$line" =~ \"alias\"[[:space:]]*:[[:space:]]*\"([^\"]*)\" ]]; then
      local alias="${BASH_REMATCH[1]}"
      # Read next few lines to get name, base_url, tenant_id
      local block="$line"
      for i in {1..10}; do
        read -r next_line || break
        block+="$next_line"
        if [[ "$next_line" =~ ^[[:space:]]*\} ]]; then
          break
        fi
      done
      
      local name=$(echo "$block" | grep -o '"name"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"name"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
      local base_url=$(echo "$block" | grep -o '"base_url"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"base_url"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
      local tenant_id=$(echo "$block" | grep -o '"tenant_id"[[:space:]]*:[[:space:]]*"[^"]*"' | sed 's/"tenant_id"[[:space:]]*:[[:space:]]*"\([^"]*\)"/\1/')
      
      echo "Alias: $alias"
      echo "Name: $name"
      echo "Base URL: $base_url"
      echo "Tenant ID: $tenant_id"
      echo ""
      env_count=$((env_count + 1))
    fi
  done <<< "$json"
}

# Fallback function to select environment by alias
# Usage: json_select_by_alias "json_string" "alias"
json_select_by_alias() {
  local json="$1"
  local search_alias="$2"
  
  # Find the environment block that contains the matching alias
  local in_env=false
  local brace_count=0
  local env_block=""
  
  while IFS= read -r line; do
    # Check if we're starting an environment object
    if [[ "$line" =~ \{[[:space:]]*$ ]] && ! $in_env; then
      in_env=true
      brace_count=1
      env_block="$line"
      continue
    fi
    
    if $in_env; then
      env_block+="
$line"
      
      # Track braces
      if [[ "$line" =~ \{ ]]; then
        brace_count=$((brace_count + 1))
      fi
      if [[ "$line" =~ \} ]]; then
        brace_count=$((brace_count - 1))
      fi
      
      # When we close the environment object
      if [ $brace_count -eq 0 ]; then
        # Check if this block contains our alias
        if echo "$env_block" | grep -q "\"alias\"[[:space:]]*:[[:space:]]*\"$search_alias\""; then
          echo "$env_block"
          return 0
        fi
        # Reset for next environment
        in_env=false
        env_block=""
      fi
    fi
  done <<< "$json"
  
  return 1
}

# Function to load environments.json
load_environments() {
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local env_file="$script_dir/helper/environments/environments.json"
  
  if [ ! -f "$env_file" ]; then
    echo "Warning: environments.json not found at $env_file" >&2
    return 1
  fi
  
  cat "$env_file"
}

# Function to list available environments
show_environments() {
  local environments=$(load_environments)
  if [ $? -ne 0 ]; then
    echo "No environments configured."
    return 1
  fi
  
  echo "Available Environments:"
  echo "======================"
  echo ""
  
  # Parse JSON and display environments
  if [ "$JQ_AVAILABLE" = true ]; then
    echo "$environments" | jq -r '.environments[] | "Alias: \(.alias)\nName: \(.name)\nBase URL: \(.base_url)\nTenant ID: \(.tenant_id)\n"'
  else
    json_list_environments "$environments"
  fi
  
  echo "Usage: $0 --env <alias>"
}

# Function to decode base64
decode_base64() {
  echo "$1" | base64 -d 2>/dev/null || echo "$1"
}

# Function to select environment
select_environment() {
  local environments="$1"
  local cli_env_alias="$2"
  
  # Priority 1: CLI parameter
  if [ -n "$cli_env_alias" ]; then
    echo "Selecting environment from CLI parameter: $cli_env_alias" >&2
    local selected
    if [ "$JQ_AVAILABLE" = true ]; then
      selected=$(echo "$environments" | jq --arg alias "$cli_env_alias" '.environments[] | select(.alias == $alias)')
    else
      selected=$(json_select_by_alias "$environments" "$cli_env_alias")
    fi
    
    if [ -n "$selected" ]; then
      echo "$selected"
      return 0
    else
      echo "[X] ERROR: Environment '$cli_env_alias' not found!" >&2
      echo "" >&2
      show_environments
      exit 1
    fi
  fi
  
  # HOSTNAME_ENV_DETECTION_PLACEHOLDER
  
  # Priority 2: File detection from .station files
  local file_detection_enabled="@FILE_DETECTION_ENABLED@"
  if [ "$file_detection_enabled" = "True" ]; then
    echo "[2] File Detection: Checking for environment in .station file..." >&2
    
    # Determine station filename based on component type
    local station_filename=""
    case "$COMPONENT_TYPE" in
    'POS') station_filename="POS.station" ;;
    'WDM') station_filename="WDM.station" ;;
    'FLOW-SERVICE') station_filename="FLOW-SERVICE.station" ;;
    'LPA-SERVICE') station_filename="LPA.station" ;;
    'STOREHUB-SERVICE') station_filename="SH.station" ;;
  esac
  
  if [ -n "$station_filename" ]; then
    local stations_dir="/usr/local/gkretail/stations"
    local station_file="$stations_dir/$station_filename"
    
    if [ -f "$station_file" ]; then
      echo "    Checking station file: $station_file" >&2
      
      # Look for Environment= line in station file
      if grep -q "^Environment=" "$station_file" 2>/dev/null; then
        local file_env=$(grep "^Environment=" "$station_file" | cut -d'=' -f2 | tr -d '\r\n' | xargs)
        if [ -n "$file_env" ]; then
          echo "    Found Environment=$file_env in station file" >&2
          local selected
          if [ "$JQ_AVAILABLE" = true ]; then
            selected=$(echo "$environments" | jq --arg alias "$file_env" '.environments[] | select(.alias == $alias)')
          else
            selected=$(json_select_by_alias "$environments" "$file_env")
          fi
          if [ -n "$selected" ]; then
            echo "    ✓ Matched environment" >&2
            echo "$selected"
            return 0
          else
            echo "    ✗ ERROR: Environment '$file_env' found in station file but not configured!" >&2
            echo "" >&2
            show_environments
            echo "" >&2
            echo "Please add environment '$file_env' to your configuration or fix the station file." >&2
            exit 1
          fi
        fi
      else
        echo "    No Environment= line found in station file" >&2
      fi
    else
      echo "    Station file not found: $station_file" >&2
    fi
  else
    echo "    ComponentType not yet determined, skipping station file check" >&2
  fi
  else
    echo "[2] File Detection: Disabled - skipping environment detection from station files" >&2
  fi
  
  # Priority 3: Interactive prompt
  # Check if environments data is valid before trying to list
  if [ -z "$environments" ]; then
    echo "No environments configured, skipping environment selection" >&2
    return 1
  fi
  
  echo "Available environments:" >&2
  if [ "$JQ_AVAILABLE" = true ]; then
    local env_list=$(echo "$environments" | jq -r '.environments[] | "\(.alias) - \(.name)"' 2>/dev/null)
    if [ -n "$env_list" ]; then
      echo "$env_list" >&2
    else
      echo "No valid environments found" >&2
      return 1
    fi
  else
    # Simple fallback list
    local found_envs=false
    while IFS= read -r line; do
      if [[ "$line" =~ \"alias\"[[:space:]]*:[[:space:]]*\"([^\"]*)\" ]]; then
        found_envs=true
        local alias="${BASH_REMATCH[1]}"
        # Try to find name on next few lines
        local block="$line"
        for i in {1..5}; do
          read -r next_line || break
          block+="$next_line"
          if [[ "$next_line" =~ \"name\"[[:space:]]*:[[:space:]]*\"([^\"]*)\" ]]; then
            local name="${BASH_REMATCH[1]}"
            echo "$alias - $name" >&2
            break
          fi
        done
      fi
    done <<< "$environments"
    
    if [ "$found_envs" = false ]; then
      echo "No valid environments found" >&2
      return 1
    fi
  fi
  echo "" >&2
  read -p "Enter environment alias (or press Enter to skip): " user_env
  
  if [ -n "$user_env" ]; then
    if [ "$JQ_AVAILABLE" = true ]; then
      echo "$environments" | jq --arg alias "$user_env" '.environments[] | select(.alias == $alias)'
    else
      json_select_by_alias "$environments" "$user_env"
    fi
    return 0
  fi
  
  echo "" >&2
  return 1
}

# Function to apply environment configuration
apply_environment_config() {
  local env_json="$1"
  
  # Extract and set variables (export tenant_id so it's available globally)
  if [ "$JQ_AVAILABLE" = true ]; then
    base_url=$(echo "$env_json" | jq -r '.base_url')
    new_tenant_id=$(echo "$env_json" | jq -r '.tenant_id // empty')
  else
    base_url=$(json_extract "$env_json" "base_url")
    new_tenant_id=$(json_extract "$env_json" "tenant_id")
  fi

  # Only override tenant_id if environment specifies a value
  if [ -n "$new_tenant_id" ]; then
    tenant_id="$new_tenant_id"
  fi
  
  # Export tenant_id so it's available outside this function
  export tenant_id
  
  echo "Applying environment configuration:" >&2
  echo "  Base URL: $base_url" >&2
  echo "  Tenant ID: $tenant_id" >&2
  
  # Get script directory
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local tokens_dir="$script_dir/helper/tokens"
  
  # Update OAuth2 credentials if provided
  local oauth2_password_b64
  if [ "$JQ_AVAILABLE" = true ]; then
    oauth2_password_b64=$(echo "$env_json" | jq -r '.launchpad_oauth2_b64 // empty')
  else
    oauth2_password_b64=$(json_extract "$env_json" "launchpad_oauth2_b64")
  fi
  
  if [ -n "$oauth2_password_b64" ]; then
    # Backup original credentials on first environment application
    if [ ! -f "$tokens_dir/basic_auth_password.txt.default" ]; then
      cp "$tokens_dir/basic_auth_password.txt" "$tokens_dir/basic_auth_password.txt.default" 2>/dev/null
    fi
    # Store as base64 (consistent with generator)
    echo "$oauth2_password_b64" > "$tokens_dir/basic_auth_password.txt"
    echo "  Updated OAuth2 credentials" >&2
  fi

  # Update Employee Hub credentials if provided
  local eh_username
  local eh_password_b64
  if [ "$JQ_AVAILABLE" = true ]; then
    eh_username=$(echo "$env_json" | jq -r '.eh_launchpad_username // empty')
    eh_password_b64=$(echo "$env_json" | jq -r '.eh_launchpad_password_b64 // empty')
  else
    eh_username=$(json_extract "$env_json" "eh_launchpad_username")
    eh_password_b64=$(json_extract "$env_json" "eh_launchpad_password_b64")
  fi

  if [ -n "$eh_username" ] && [ -n "$eh_password_b64" ]; then
    # Backup original credentials on first environment application
    if [ ! -f "$tokens_dir/form_password.txt.default" ]; then
      cp "$tokens_dir/form_password.txt" "$tokens_dir/form_password.txt.default" 2>/dev/null
      cp "$tokens_dir/form_username.txt" "$tokens_dir/form_username.txt.default" 2>/dev/null
    fi
    # Store password as base64 (consistent with generator)
    echo "$eh_username" > "$tokens_dir/form_username.txt"
    echo "$eh_password_b64" > "$tokens_dir/form_password.txt"
    echo "  Updated Employee Hub credentials" >&2
  fi
  
  # Update tenant_id in all helper JSON files
  update_helper_json_tenant_id "$tenant_id" "$eh_username"
  
  echo "Environment configuration applied successfully" >&2
}

# Function to update tenant_id and username in helper JSON files
update_helper_json_tenant_id() {
  local new_tenant_id="$1"
  local new_username="$2"
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local helper_dir="$script_dir/helper"
  
  echo "Updating helper JSON files with tenant_id: $new_tenant_id" >&2
  
  # Update onboarding JSON files
  if [ -d "$helper_dir/onboarding" ]; then
    for json_file in "$helper_dir/onboarding"/*.json; do
      if [ -f "$json_file" ]; then
        if [ "$JQ_AVAILABLE" = true ]; then
          # Use jq to update tenant_id fields
          temp_file=$(mktemp)
          jq --arg tid "$new_tenant_id" '
            if .tenant_id then .tenant_id = $tid else . end |
            if .tenantId then .tenantId = $tid else . end |
            if .restrictions.tenantId then .restrictions.tenantId = $tid else . end
          ' "$json_file" > "$temp_file" && mv "$temp_file" "$json_file"
        else
          # Fallback: use sed for simple replacements
          sed -i "s/\"tenant_id\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"tenant_id\": \"$new_tenant_id\"/g" "$json_file"
          sed -i "s/\"tenantId\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"tenantId\": \"$new_tenant_id\"/g" "$json_file"
        fi
        echo "  Updated $(basename "$json_file")" >&2
      fi
    done
  fi
  
  # Update init/get_store.json
  local get_store_json="$helper_dir/init/get_store.json"
  if [ -f "$get_store_json" ]; then
    if [ "$JQ_AVAILABLE" = true ]; then
      temp_file=$(mktemp)
      jq --arg tid "$new_tenant_id" '.station.tenantId = $tid' "$get_store_json" > "$temp_file" && mv "$temp_file" "$get_store_json"
    else
      sed -i "s/\"tenantId\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"tenantId\": \"$new_tenant_id\"/g" "$get_store_json"
    fi
    echo "  Updated get_store.json" >&2
  fi
  
  # Update init/storehub/update_config.json with username if provided
  if [ -n "$new_username" ]; then
    local storehub_config="$helper_dir/init/storehub/update_config.json"
    if [ -f "$storehub_config" ]; then
      if [ "$JQ_AVAILABLE" = true ]; then
        temp_file=$(mktemp)
        jq --arg usr "$new_username" '.user = $usr' "$storehub_config" > "$temp_file" && mv "$temp_file" "$storehub_config"
      else
        sed -i "s/\"user\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"user\": \"$new_username\"/g" "$storehub_config"
      fi
      echo "  Updated storehub/update_config.json" >&2
    fi
  fi
  
  # Update structure/create_structure.json
  local create_structure_json="$helper_dir/structure/create_structure.json"
  if [ -f "$create_structure_json" ]; then
    # First handle template placeholders
    sed -i "s/@TENANT_ID@/$new_tenant_id/g" "$create_structure_json"
    
    # Then handle actual JSON values
    if [ "$JQ_AVAILABLE" = true ]; then
      temp_file=$(mktemp)
      jq_cmd='. | if .tenant.tenantId then .tenant.tenantId = $tid else . end'
      if [ -n "$new_username" ]; then
        jq_cmd="$jq_cmd | if .user then .user = \$usr else . end"
        jq --arg tid "$new_tenant_id" --arg usr "$new_username" "$jq_cmd" "$create_structure_json" > "$temp_file" && mv "$temp_file" "$create_structure_json"
      else
        jq --arg tid "$new_tenant_id" "$jq_cmd" "$create_structure_json" > "$temp_file" && mv "$temp_file" "$create_structure_json"
      fi
    else
      sed -i "s/\"tenantId\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"tenantId\": \"$new_tenant_id\"/g" "$create_structure_json"
      if [ -n "$new_username" ]; then
        sed -i "s/\"user\"[[:space:]]*:[[:space:]]*\"[^\"]*\"/\"user\": \"$new_username\"/g" "$create_structure_json"
      fi
    fi
    echo "  Updated create_structure.json" >&2
  fi
  
  echo "Helper JSON files updated successfully" >&2
}

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

# Function to extract version from any package filename
get_package_version() {
  local package_file="$1"
  local component_prefix="$2"
  
  # Get filename without extension
  local filename=$(basename "$package_file" | sed 's/\.[^.]*$//')
  
  # Try different patterns to extract version
  
  # Pattern 1: prefix-1.2.3 (standard format)
  if [[ "$filename" =~ ^$component_prefix-([0-9]+(\.[0-9]+)*)$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # Pattern 2: prefix-1.2.3-suffix (with additional info)
  if [[ "$filename" =~ ^$component_prefix-([0-9]+(\.[0-9]+)*)\- ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # Pattern 3: prefix_1_2_3 (underscore format)
  if [[ "$filename" =~ ^$component_prefix[_-]([0-9]+)[_\.]([0-9]+)[_\.]([0-9]+) ]]; then
    echo "${BASH_REMATCH[1]}.${BASH_REMATCH[2]}.${BASH_REMATCH[3]}"
    return 0
  fi
  
  # Pattern 4: prefix1.2.3 (no separator)
  if [[ "$filename" =~ ^$component_prefix([0-9]+(\.[0-9]+)*)$ ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # Pattern 5: just extract any sequence of numbers and dots
  if [[ "$filename" =~ ([0-9]+(\.[0-9]+)*) ]]; then
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # If no pattern matches, return the original filename without prefix
  local version=${filename/#$component_prefix-/}
  if [ -z "$version" ]; then
    echo "Error: Could not extract version from filename $package_file"
    return 1
  fi
  
  echo "$version"
}

# Function to get JRE version from filename
get_jre_version() {
  local jre_zip="$1"
  
  # Get filename without extension
  local filename=$(basename "$jre_zip" | sed 's/\.[^.]*$//')
  
  # Special case for Java_zulujre pattern
  if [[ "$filename" =~ Java_zulujre.*?[-_]([0-9]+\.[0-9]+\.[0-9]+) ]]; then
    # Log detection but only return the version
    echo >&2 "Detected Java version ${BASH_REMATCH[1]} from Zulu JRE filename"
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # Special case for x64/x86 in filename to avoid extracting "64" as version
  if [[ "$filename" =~ x64-([0-9]+\.[0-9]+\.[0-9]+) ]]; then
    # Log detection but only return the version
    echo >&2 "Detected Java version ${BASH_REMATCH[1]} from x64 pattern"
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  if [[ "$filename" =~ x86-([0-9]+\.[0-9]+\.[0-9]+) ]]; then
    # Log detection but only return the version
    echo >&2 "Detected Java version ${BASH_REMATCH[1]} from x86 pattern"
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  # Try jre prefix first, then java if that fails
  local version=$(get_package_version "$jre_zip" "jre")
  if [ -z "$version" ]; then
    version=$(get_package_version "$jre_zip" "java")
  fi
  
  # Validate version format - if it's just a number like "64", it's probably wrong
  if [[ "$version" =~ ^[0-9]+$ ]] && [[ "$filename" =~ ([0-9]+\.[0-9]+\.[0-9]+) ]]; then
    # Extract version with format like 11.0.18
    echo >&2 "Correcting invalid version '$version' to ${BASH_REMATCH[1]}"
    echo "${BASH_REMATCH[1]}"
    return 0
  fi
  
  echo "$version"
}

# Function to get Tomcat version from filename
get_tomcat_version() {
  local tomcat_zip="$1"
  get_package_version "$tomcat_zip" "tomcat"
}

# Function to fetch default versions from Employee Hub Service API
get_default_versions() {
  local base_url="$1"
  local tenant_id="${2:-001}"
  local result_version=""

  echo "Fetching default versions from Employee Hub Service API..." >&2

  # Get bearer token from access_token.txt (should be fresh from onboarding)
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local token_file="$script_dir/helper/tokens/access_token.txt"

  if [ ! -f "$token_file" ]; then
    echo "Warning: Bearer token file not found at $token_file" >&2
    return 1
  fi

  local bearer_token=$(cat "$token_file" | tr -d '\n\r ')
  if [ -z "$bearer_token" ]; then
    echo "Warning: Bearer token is empty" >&2
    return 1
  fi

  echo "Fetching component version using FP-first, FPD-fallback strategy for $COMPONENT_TYPE..." >&2

  local result_version=""
  local version_source=""

  # Step 1: Try FP scope first (modified/customized versions)
  echo "Step 1: Checking FP scope for modified/customized version..." >&2
  local fp_api_url="https://$base_url/employee-hub-service/services/rest/v1/properties?scope=FP&referenceId=platform"

  local fp_response=$(curl -s -k \
    -H "authorization: Bearer $bearer_token" \
    -H "gk-tenant-id: $tenant_id" \
    -H "Referer: https://$base_url/employee-hub/app/index.html" \
    "$fp_api_url")

  if [ $? -eq 0 ] && [ -n "$fp_response" ]; then
    # Parse JSON response and extract version for the requested component
    # Try Update_Version first (preferred), then fall back to Version
    case "$COMPONENT_TYPE" in
      "POS")
        result_version=$(echo "$fp_response" | grep -o '"propertyId":"POSClient_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        if [ -z "$result_version" ]; then
          result_version=$(echo "$fp_response" | grep -o '"propertyId":"POSClient_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        fi
        ;;
      "WDM")
        result_version=$(echo "$fp_response" | grep -o '"propertyId":"WDM_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        if [ -z "$result_version" ]; then
          result_version=$(echo "$fp_response" | grep -o '"propertyId":"WDM_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        fi
        ;;
      "FLOW-SERVICE")
        result_version=$(echo "$fp_response" | grep -o '"propertyId":"FlowService_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        if [ -z "$result_version" ]; then
          result_version=$(echo "$fp_response" | grep -o '"propertyId":"FlowService_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        fi
        ;;
      "LPA-SERVICE")
        result_version=$(echo "$fp_response" | grep -o '"propertyId":"LPA_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        if [ -z "$result_version" ]; then
          result_version=$(echo "$fp_response" | grep -o '"propertyId":"LPA_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        fi
        ;;
      "STOREHUB-SERVICE")
        result_version=$(echo "$fp_response" | grep -o '"propertyId":"SH_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        if [ -z "$result_version" ]; then
          result_version=$(echo "$fp_response" | grep -o '"propertyId":"StoreHub_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
        fi
        ;;
    esac

    if [ -n "$result_version" ]; then
      version_source="FP (Modified)"
      echo "Found $COMPONENT_TYPE version in FP scope: $result_version" >&2
    fi
  else
    echo "Warning: FP scope request failed" >&2
  fi

  # Step 2: If not found in FP, try FPD scope (default versions)
  if [ -z "$result_version" ]; then
    echo "Step 2: Checking FPD scope for default version..." >&2
    local fpd_api_url="https://$base_url/employee-hub-service/services/rest/v1/properties?scope=FPD&referenceId=platform"

    local fpd_response=$(curl -s -k \
      -H "authorization: Bearer $bearer_token" \
      -H "gk-tenant-id: $tenant_id" \
      -H "Referer: https://$base_url/employee-hub/app/index.html" \
      "$fpd_api_url")

    if [ $? -eq 0 ] && [ -n "$fpd_response" ]; then
      # Parse JSON response and extract version for the requested component
      # Try Update_Version first (preferred), then fall back to Version
      case "$COMPONENT_TYPE" in
        "POS")
          result_version=$(echo "$fpd_response" | grep -o '"propertyId":"POSClient_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          if [ -z "$result_version" ]; then
            result_version=$(echo "$fpd_response" | grep -o '"propertyId":"POSClient_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          fi
          ;;
        "WDM")
          result_version=$(echo "$fpd_response" | grep -o '"propertyId":"WDM_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          if [ -z "$result_version" ]; then
            result_version=$(echo "$fpd_response" | grep -o '"propertyId":"WDM_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          fi
          ;;
        "FLOW-SERVICE")
          result_version=$(echo "$fpd_response" | grep -o '"propertyId":"FlowService_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          if [ -z "$result_version" ]; then
            result_version=$(echo "$fpd_response" | grep -o '"propertyId":"FlowService_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          fi
          ;;
        "LPA-SERVICE")
          result_version=$(echo "$fpd_response" | grep -o '"propertyId":"LPA_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          if [ -z "$result_version" ]; then
            result_version=$(echo "$fpd_response" | grep -o '"propertyId":"LPA_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          fi
          ;;
        "STOREHUB-SERVICE")
          result_version=$(echo "$fpd_response" | grep -o '"propertyId":"SH_Update_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          if [ -z "$result_version" ]; then
            result_version=$(echo "$fpd_response" | grep -o '"propertyId":"StoreHub_Version"[^}]*"value":"[^"]*"' | sed 's/.*"value":"\([^"]*\)".*/\1/')
          fi
          ;;
      esac

      if [ -n "$result_version" ]; then
        version_source="FPD (Default)"
        echo "Found $COMPONENT_TYPE version in FPD scope: $result_version" >&2
      fi
    else
      echo "Warning: FPD scope request failed" >&2
    fi
  fi

  # Return the result
  if [ -n "$result_version" ]; then
    echo "Successfully fetched $COMPONENT_TYPE version: $result_version ($version_source)" >&2
    echo "$result_version"
    return 0
  else
    echo "Warning: No version found for component type $COMPONENT_TYPE in either FP or FPD scope" >&2
    return 1
  fi
}

# Function to fetch default versions from Config-Service API
get_default_versions_config_service() {
  local base_url="$1"
  local tenant_id="${2:-001}"
  local system_name="$3"
  local result_version=""

  echo "Fetching default versions from Config-Service API..." >&2

  # Get bearer token from access_token.txt
  local script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  local token_file="$script_dir/helper/tokens/access_token.txt"

  if [ ! -f "$token_file" ]; then
    echo "Warning: Bearer token file not found at $token_file" >&2
    return 1
  fi

  local bearer_token=$(cat "$token_file" | tr -d '\n\r ')
  if [ -z "$bearer_token" ]; then
    echo "Warning: Bearer token is empty" >&2
    return 1
  fi

  # API URL
  local api_url="https://$base_url/api/config/services/rest/infrastructure/v1/versions/search"
  echo "Using Config-Service API: $api_url" >&2
  echo "Fetching versions for $COMPONENT_TYPE (systemName: $system_name)..." >&2

  # Make POST request
  local response=$(curl -s -k \
    -X POST \
    -H "authorization: Bearer $bearer_token" \
    -H "content-type: application/json" \
    -d "{\"systemName\":\"$system_name\"}" \
    "$api_url")

  if [ $? -eq 0 ] && [ -n "$response" ]; then
    # Extract first version from versionNameList array
    result_version=$(echo "$response" | grep -o '"versionNameList":\["[^"]*"' | sed 's/.*"versionNameList":\["\([^"]*\)".*/\1/')

    if [ -n "$result_version" ]; then
      echo "Found $COMPONENT_TYPE version: $result_version (Config-Service)" >&2
      echo "$result_version"
      return 0
    else
      echo "Warning: No versions found for $COMPONENT_TYPE" >&2
    fi
  else
    echo "Warning: Config-Service API request failed" >&2
  fi

  return 1
}

# ============================================================================
# MULTI-ENVIRONMENT SUPPORT - Load and Apply Environment Configuration
# ============================================================================

# Initialize tenant_id from main configuration (can be overridden by environment)
tenant_id="@TENANT_ID@"

# Handle list-environments flag
if [ "$list_environments" = true ]; then
  show_environments
  exit 0
fi

# ============================================================================
# SCRIPT CONFIGURATION (may be overridden by environment config above)
# ============================================================================

# Update these lines to use the base_url
server="$base_url"
dsg_server="$base_url"

# Basic configuration
version="v1.0.0"
base_install_dir="/usr/local/gkretail"

# Set component-specific configurations
case "$COMPONENT_TYPE" in
  'POS')
    systemType="CSE-OPOS-CLOUD"
    install_dir="$base_install_dir/pos-full"
    ;;
  'WDM')
    systemType="CSE-wdm"
    install_dir="$base_install_dir/wdm"
    ;;
  'FLOW-SERVICE')
    systemType="CSE-FLOWSERVICE-CLOUD"
    install_dir="$base_install_dir/flow-service"
    ;;
  'LPA-SERVICE')
    systemType="CSE-lps-lpa"
    install_dir="$base_install_dir/lpa-service"
    ;;
  'STOREHUB-SERVICE')
    systemType="CSE-sh-cloud"
    install_dir="$base_install_dir/storehub-service"
    ;;
  *)
    systemType="CSE-OPOS-CLOUD"
    install_dir="$base_install_dir/wdm"
    ;;
esac

# Create installation directory if it doesn't exist
mkdir -p "$install_dir"

# Check if this is an update of an existing installation
isUpdate=false
if [ -d "$install_dir" ]; then
    # Check for log folders
    logPath="$install_dir/log"
    logsPath="$install_dir/logs"

    # Determine which log folder exists
    logFolderPath=""
    if [ -d "$logPath" ]; then
        logFolderPath="$logPath"
    elif [ -d "$logsPath" ]; then
        logFolderPath="$logsPath"
    fi

    # If a log folder exists, check for recent activity (last 7 days)
    if [ -n "$logFolderPath" ]; then
        echo "Found existing installation at $install_dir with log folder at $logFolderPath"

        # Get files modified in the last 7 days
        recentFiles=$(find "$logFolderPath" -type f -mtime -7 2>/dev/null)
        recentFileCount=$(echo "$recentFiles" | grep -v '^$' | wc -l)

        if [ $recentFileCount -gt 0 ]; then
            echo "Found $recentFileCount recently modified log files (within 7 days)"
            echo "This appears to be an active installation. Performing update instead of full installation."
            isUpdate=true
        else
            echo "No recent activity found in logs. Performing full installation."
        fi
    else
        echo "No log folder found. Performing full installation."
    fi
else
    echo "Installation directory does not exist. Performing full installation."
fi

# Multi-environment selection (skip in update mode)
if [ "$isUpdate" = false ]; then
  # Load environments configuration
  if environments=$(load_environments 2>/dev/null); then
    # Select environment based on CLI parameter, file, or interactive prompt
    if selected_env=$(select_environment "$environments" "$env_alias"); then
      # Apply the selected environment configuration (overrides base_url, credentials, tenant_id)
      apply_environment_config "$selected_env"
      if [ "$JQ_AVAILABLE" = true ]; then
        env_alias_name=$(echo "$selected_env" | jq -r '.alias')
      else
        env_alias_name=$(json_extract "$selected_env" "alias")
      fi
      echo "Environment '$env_alias_name' applied successfully"
    else
      echo "No environment selected, using script defaults"
      # Restore original credentials if they were backed up
      script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
      tokens_dir="$script_dir/helper/tokens"
      if [ -f "$tokens_dir/basic_auth_password.txt.default" ]; then
        cp "$tokens_dir/basic_auth_password.txt.default" "$tokens_dir/basic_auth_password.txt"
        echo "Restored original OAuth2 credentials"
      fi
      if [ -f "$tokens_dir/form_password.txt.default" ]; then
        cp "$tokens_dir/form_password.txt.default" "$tokens_dir/form_password.txt"
        echo "Restored original Employee Hub password"
      fi
      if [ -f "$tokens_dir/form_username.txt.default" ]; then
        cp "$tokens_dir/form_username.txt.default" "$tokens_dir/form_username.txt"
        echo "Restored original Employee Hub username"
      fi
    fi
  else
    echo "Warning: No environments.json found, using script defaults"
    # Restore original credentials if they were backed up
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    tokens_dir="$script_dir/helper/tokens"
    if [ -f "$tokens_dir/basic_auth_password.txt.default" ]; then
      cp "$tokens_dir/basic_auth_password.txt.default" "$tokens_dir/basic_auth_password.txt"
      echo "Restored original OAuth2 credentials"
    fi
    if [ -f "$tokens_dir/form_password.txt.default" ]; then
      cp "$tokens_dir/form_password.txt.default" "$tokens_dir/form_password.txt"
      echo "Restored original Employee Hub password"
    fi
    if [ -f "$tokens_dir/form_username.txt.default" ]; then
      cp "$tokens_dir/form_username.txt.default" "$tokens_dir/form_username.txt"
      echo "Restored original Employee Hub username"
    fi
  fi
else
  echo "Update mode detected - skipping environment selection, will use existing installation configuration"
fi

# Determine component version based on use_default_versions flag
if [ "$use_default_versions" = true ]; then
  echo "UseDefaultVersions flag is enabled - fetching versions from Employee Hub Service API..."

  # tenant_id is already set from main config or overridden by apply_environment_config if an environment was selected

  # First, ensure we have a fresh OAuth token (just the token, not full onboarding)
  echo "Getting fresh OAuth token for version API call..."

  # Get script directory
  script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
  tokens_path="$script_dir/helper/tokens"
  basic_auth_path="$tokens_path/basic_auth_password.txt"
  form_password_path="$tokens_path/form_password.txt"
  form_username_path="$tokens_path/form_username.txt"

  # Check if credential files exist and get OAuth token
  if [ -f "$basic_auth_path" ] && [ -f "$form_password_path" ]; then
    # Read credentials (should be plain text, but auto-detect base64)
    # Use tr -d to remove any trailing newlines or carriage returns
    username="launchpad"
    basic_auth_password=$(cat "$basic_auth_path" | tr -d '\n\r')
    form_password=$(cat "$form_password_path" | tr -d '\n\r')
    
    echo "[DEBUG] Credential files found"
    echo "[DEBUG] Basic auth username: $username"
    echo "[DEBUG] Basic auth password length: ${#basic_auth_password}"
    echo "[DEBUG] Form password length: ${#form_password}"
    
    # Auto-detect and decode base64 if needed
    # Check if basic_auth_password looks like base64 (only alphanumeric + / + = characters)
    if [[ "$basic_auth_password" =~ ^[A-Za-z0-9+/]+=*$ ]]; then
      # Use tr to remove any newlines/carriage returns before decoding
      decoded_basic=$(echo "$basic_auth_password" | tr -d '\n\r' | base64 -d 2>/dev/null)
      if [ $? -eq 0 ] && [ -n "$decoded_basic" ]; then
        echo "[DEBUG] Basic auth password detected as base64-encoded, decoding..."
        basic_auth_password="$decoded_basic"
        echo "[DEBUG] Basic auth password decoded (length: ${#basic_auth_password})"
      fi
    fi
    
    # Auto-detect and decode form password if needed
    if [[ "$form_password" =~ ^[A-Za-z0-9+/]+=*$ ]]; then
      # Use tr to remove any newlines/carriage returns before decoding
      decoded_form=$(echo "$form_password" | tr -d '\n\r' | base64 -d 2>/dev/null)
      if [ $? -eq 0 ] && [ -n "$decoded_form" ]; then
        echo "[DEBUG] Form password detected as base64-encoded, decoding..."
        form_password="$decoded_form"
        echo "[DEBUG] Form password decoded (length: ${#form_password})"
      fi
    fi
    
    # Read form username from file if available, otherwise use template default
    if [ -f "$form_username_path" ]; then
      form_username=$(cat "$form_username_path")
      echo "[DEBUG] Form username from file: $form_username"
    else
      form_username="@FORM_USERNAME@"
      echo "[DEBUG] Form username from template: $form_username"
    fi

    if [ -n "$basic_auth_password" ] && [ -n "$form_password" ]; then
      # Create Basic Auth header (same as onboarding.sh)
      auth_string=$(echo -n "$username:$basic_auth_password" | base64 | tr -d '\n')
      echo "[DEBUG] Basic Auth header created"

      # URL encoding function (same as onboarding.sh)
      urlencode() {
        local string="$1"
        local encoded=""
        local i char
        for (( i=0; i<${#string}; i++ )); do
          char="${string:$i:1}"
          case "$char" in
            [a-zA-Z0-9.~_-]) encoded+="$char" ;;
            *) printf -v char '%%%02X' "'$char"; encoded+="$char" ;;
          esac
        done
        echo "$encoded"
      }

      # Form data with URL encoding (same as onboarding.sh)
      username_encoded=$(urlencode "$form_username")
      password_encoded=$(urlencode "$form_password")
      form_data="username=${username_encoded}&password=${password_encoded}&grant_type=password"
      echo "[DEBUG] Form data prepared"

      # Get OAuth token (same URL as onboarding.sh)
      token_url="https://$base_url/auth-service/tenants/$tenant_id/oauth/token"
      echo "[DEBUG] Token URL: $token_url"
      echo "[DEBUG] Making OAuth token request..."
      
      response=$(curl -s -X POST "$token_url" \
        -H "Authorization: Basic $auth_string" \
        -H "Content-Type: application/x-www-form-urlencoded" \
        -d "$form_data")
      
      curl_exit_code=$?
      echo "[DEBUG] OAuth API request completed (status: $curl_exit_code)"

      if [ $curl_exit_code -eq 0 ] && [ -n "$response" ]; then
        # Extract access token from JSON response
        access_token=$(echo "$response" | grep -o '"access_token":"[^"]*"' | sed 's/"access_token":"\([^"]*\)"/\1/')

        if [ -n "$access_token" ]; then
          # Save the access token (same as onboarding.sh)
          token_file="$tokens_path/access_token.txt"
          echo -n "$access_token" > "$token_file"
          echo "OAuth token obtained and saved successfully"
        else
          echo "[ERROR] Could not extract access token from response"
          echo "[DEBUG] API Response: $response"
          echo "Warning: Could not extract access token from response, proceeding with existing token..."
        fi
      else
        echo "[ERROR] OAuth token request failed (curl status: $curl_exit_code)"
        echo "[DEBUG] API Response: $response"
        echo "Warning: Failed to get OAuth token, proceeding with existing token..."
      fi
    else
      echo "[ERROR] Credentials are empty"
      echo "[DEBUG] Basic auth password empty: $([ -z "$basic_auth_password" ] && echo 'YES' || echo 'NO')"
      echo "[DEBUG] Form password empty: $([ -z "$form_password" ] && echo 'YES' || echo 'NO')"
      echo "Warning: Credentials are empty, proceeding with existing token..."
    fi
  else
    echo "[ERROR] Required credential files not found"
    echo "[DEBUG] Basic auth path exists: $([ -f "$basic_auth_path" ] && echo 'YES' || echo 'NO') - $basic_auth_path"
    echo "[DEBUG] Form password path exists: $([ -f "$form_password_path" ] && echo 'YES' || echo 'NO') - $form_password_path"
    echo "Warning: Required credential files not found, proceeding with existing token..."
  fi

  # Fetch default version from API based on version_source
  echo "Using version_source: $version_source"
  
  if [ "$version_source" = "CONFIG" ]; then
    # Use Config-Service API
    echo "Fetching versions from Config-Service..."
    
    # Determine system name based on component type
    case "$COMPONENT_TYPE" in
      'POS')
        system_name="@POS_SYSTEM_TYPE@"
        ;;
      'WDM')
        system_name="@WDM_SYSTEM_TYPE@"
        ;;
      'FLOW-SERVICE')
        system_name="@FLOW_SERVICE_SYSTEM_TYPE@"
        ;;
      'LPA-SERVICE')
        system_name="@LPA_SERVICE_SYSTEM_TYPE@"
        ;;
      'STOREHUB-SERVICE')
        system_name="@STOREHUB_SERVICE_SYSTEM_TYPE@"
        ;;
      *)
        system_name=""
        ;;
    esac
    
    if [ -n "$system_name" ]; then
      api_version=$(get_default_versions_config_service "$base_url" "$tenant_id" "$system_name")
    fi
  else
    # Use Function Pack (FP/FPD) API (default)
    echo "Fetching versions from Function Pack (FP/FPD)..."
    api_version=$(get_default_versions "$base_url" "$tenant_id")
  fi
  
  if [ -n "$api_version" ]; then
    component_version="$api_version"
    echo "Using API version for $COMPONENT_TYPE: $component_version"
  else
    echo "Warning: Could not get version for $COMPONENT_TYPE from API, falling back to hardcoded version"
    # Fall back to hardcoded versions
    case "$systemType" in
      "CSE-OPOS-CLOUD")
        component_version="@POS_VERSION@"
        ;;
      "CSE-wdm")
        component_version="@WDM_VERSION@"
        ;;
      "CSE-FLOWSERVICE-CLOUD")
        component_version="@FLOW_SERVICE_VERSION@"
        ;;
      "CSE-lps-lpa")
        component_version="@LPA_SERVICE_VERSION@"
        ;;
      "CSE-sh-cloud")
        component_version="@STOREHUB_SERVICE_VERSION@"
        ;;
      *)
        component_version=""
        ;;
    esac
  fi
else
  echo "Using hardcoded versions from configuration..."
  # Set component-specific version if available
  case "$systemType" in
    "CSE-OPOS-CLOUD")
      component_version="@POS_VERSION@"
      ;;
    "CSE-wdm")
      component_version="@WDM_VERSION@"
      ;;
    "CSE-FLOWSERVICE-CLOUD")
      component_version="@FLOW_SERVICE_VERSION@"
      ;;
    "CSE-lps-lpa")
      component_version="@LPA_SERVICE_VERSION@"
      ;;
    "CSE-sh-cloud")
      component_version="@STOREHUB_SERVICE_VERSION@"
      ;;
    *)
      component_version=""
      ;;
  esac
fi

# If component version is still empty, use default version
if [ -z "$component_version" ]; then
  component_version="$version"
  echo "No specific version found, using default version: $component_version"
else
  echo "Using component version: $component_version"
fi

# Initialize offline variables
jre_version=""
jre_file=""
tomcat_version=""
tomcat_file=""

# Set WDM SSL settings based on base install directory
security_dir="$base_install_dir/security"
# We'll find the actual certificate file dynamically later
ssl_password="changeit"

# For StoreHub, set the Firebird server path
firebird_server_path="@FIREBIRD_SERVER_PATH@"
# If the placeholder wasn't replaced (still contains @), use a default value
if [[ "$firebird_server_path" == *@* ]]; then
  firebird_server_path="/opt/firebird"
  echo "Using default Firebird server path: $firebird_server_path"
fi

# For StoreHub, set the Jaybird driver path
firebird_driver_path_local="@FIREBIRD_DRIVER_PATH_LOCAL@"
# If the placeholder wasn't replaced (still contains @), use a default value
if [[ "$firebird_driver_path_local" == *@* ]]; then
  firebird_driver_path_local=""
  echo "No default Jaybird driver path set - will detect during installation if available"
fi

# Check offline mode
offline_mode=$offline

# Validate WDM-specific parameters
if [ "$COMPONENT_TYPE" = "WDM" ]; then
  if [ -z "$ssl_password" ]; then
    echo "Error: ssl_password is required for WDM installation"
    exit 1
  fi
fi

# Add component-specific package directory check
if [ "$COMPONENT_TYPE" = "LPA-SERVICE" ]; then
  package_dir="offline_package_LPA"
elif [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ]; then
  package_dir="offline_package_SH"
else
  package_dir="offline_package_$COMPONENT_TYPE"
fi

# Update offline mode checks
if [ "$offline_mode" = true ]; then
  # Check for component-specific offline package
  if [ ! -d "$package_dir" ]; then
    echo "Error: Offline package directory not found: $package_dir"
    exit 1
  fi

  # Check for required files based on component type
  if [ "$COMPONENT_TYPE" = "WDM" ]; then
    # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
    jre_files=()
    
    # Try different JRE patterns in Java directory
    for pattern in "Java/*.zip" "Java/*jre*.zip" "Java/*java*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        jre_files+=("${new_files[@]}")
      fi
    done
    
    tomcat_files=()
    # Try different Tomcat patterns in Tomcat directory
    for pattern in "Tomcat/*.zip" "Tomcat/*tomcat*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        tomcat_files+=("${new_files[@]}")
      fi
    done
    
    # Look for any JAR file to use as installer in the component directory
    jar_files=()
    if compgen -G "$package_dir/*.jar" > /dev/null; then
      mapfile -t jar_files < <(ls $package_dir/*.jar 2>/dev/null)
    fi
    
    installer_jar=""
    has_installer_jar=false
    
    if [ "${#jar_files[@]}" -gt 0 ]; then
      if [ "${#jar_files[@]}" -gt 1 ]; then
        echo "Warning: Multiple JAR files found in $package_dir. Using the first one: $(basename ${jar_files[0]})"
      fi
      installer_jar="${jar_files[0]}"
      has_installer_jar=true
      echo "Found installer JAR: $(basename ${jar_files[0]})"
    fi
    
    # Initialize required files with Launcher binary
    required_files=("$package_dir/Launcher.run")
    
    # Process JRE files if available
    if [ "${#jre_files[@]}" -gt 0 ]; then
      jre_file="${jre_files[0]}"
      jre_version=$(get_jre_version "$(basename ${jre_files[0]})")
      echo "Found JRE/Java package: $(basename ${jre_files[0]}), version: $jre_version"
      required_files+=("$jre_file")
    else
      echo "Error: No JRE/Java package found in Java directory"
      exit 1
    fi
    
    # Process Tomcat files if available
    if [ "${#tomcat_files[@]}" -gt 0 ]; then
      tomcat_file="${tomcat_files[0]}"
      tomcat_version=$(get_tomcat_version "$(basename ${tomcat_files[0]})")
      echo "Found Tomcat package: $(basename ${tomcat_files[0]}), version: $tomcat_version"
      required_files+=("$tomcat_file")
    else
      echo "Error: No Tomcat package found in Tomcat directory"
      exit 1
    fi
    
    # Add installer.jar to required files if it exists
    if [ "$has_installer_jar" = true ]; then
      required_files+=("$installer_jar")
    fi
  elif [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ]; then
    # For StoreHub components - with Jaybird support
    # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
    jre_files=()
    
    # Try different JRE patterns in Java directory
    for pattern in "Java/*.zip" "Java/*jre*.zip" "Java/*java*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        jre_files+=("${new_files[@]}")
      fi
    done
    
    tomcat_files=()
    # Try different Tomcat patterns in Tomcat directory
    for pattern in "Tomcat/*.zip" "Tomcat/*tomcat*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        tomcat_files+=("${new_files[@]}")
      fi
    done
    
    # Look for Jaybird JAR files
    jaybird_files=()
    if compgen -G "Jaybird/*.jar" > /dev/null; then
      mapfile -t jaybird_files < <(ls Jaybird/*.jar 2>/dev/null)
    fi
    
    jaybird_file=""
    has_jaybird=false
    
    if [ "${#jaybird_files[@]}" -gt 0 ]; then
      if [ "${#jaybird_files[@]}" -gt 1 ]; then
        echo "Warning: Multiple Jaybird JAR files found. Using the first one: $(basename ${jaybird_files[0]})"
      fi
      jaybird_file="${jaybird_files[0]}"
      has_jaybird=true
      echo "Found Jaybird driver: $(basename ${jaybird_files[0]})"
      
      # Update the firebird_driver_path_local to point to the actual JAR file, not just the directory
      firebird_driver_path_local="$jaybird_file"
      echo "Updated Jaybird driver path to: $firebird_driver_path_local"
    else
      echo "Warning: No Jaybird driver found in Jaybird directory"
    fi
    
    # Look for any JAR file to use as installer in the component directory
    jar_files=()
    if compgen -G "$package_dir/*.jar" > /dev/null; then
      mapfile -t jar_files < <(ls $package_dir/*.jar 2>/dev/null)
    fi
    
    installer_jar=""
    has_installer_jar=false
    
    if [ "${#jar_files[@]}" -gt 0 ]; then
      if [ "${#jar_files[@]}" -gt 1 ]; then
        echo "Warning: Multiple JAR files found in $package_dir. Using the first one: $(basename ${jar_files[0]})"
      fi
      installer_jar="${jar_files[0]}"
      has_installer_jar=true
      echo "Found installer JAR: $(basename ${jar_files[0]})"
    fi
    
    # Initialize required files with Launcher binary
    required_files=("$package_dir/Launcher.run")
    
    # Process JRE files if available
    if [ "${#jre_files[@]}" -gt 0 ]; then
      jre_file="${jre_files[0]}"
      jre_version=$(get_jre_version "$(basename ${jre_files[0]})")
      echo "Found JRE/Java package: $(basename ${jre_files[0]}), version: $jre_version"
      required_files+=("$jre_file")
    else
      echo "Error: No JRE/Java package found for $COMPONENT_TYPE"
      exit 1
    fi
    
    # Process Tomcat files if available
    if [ "${#tomcat_files[@]}" -gt 0 ]; then
      tomcat_file="${tomcat_files[0]}"
      tomcat_version=$(get_tomcat_version "$(basename ${tomcat_files[0]})")
      echo "Found Tomcat package: $(basename ${tomcat_files[0]}), version: $tomcat_version"
      required_files+=("$tomcat_file")
    else
      echo "Error: No Tomcat package found for $COMPONENT_TYPE"
      exit 1
    fi
    
    # Add Jaybird file to required files if it exists
    if [ "$has_jaybird" = true ]; then
      required_files+=("$jaybird_file")
    fi
    
    # Add installer.jar to required files if it exists
    if [ "$has_installer_jar" = true ]; then
      required_files+=("$installer_jar")
    fi
  else
    # For other components - generic approach with improved detection
    # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
    jre_files=()
    
    # Try different JRE patterns in Java directory
    for pattern in "Java/*.zip" "Java/*jre*.zip" "Java/*java*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        jre_files+=("${new_files[@]}")
      fi
    done
    
    tomcat_files=()
    # Try different Tomcat patterns in Tomcat directory
    for pattern in "Tomcat/*.zip" "Tomcat/*tomcat*.zip"; do
      if compgen -G "$pattern" > /dev/null; then
        mapfile -t new_files < <(ls $pattern 2>/dev/null)
        tomcat_files+=("${new_files[@]}")
      fi
    done
    
    # Look for any JAR file to use as installer in the component directory
    jar_files=()
    if compgen -G "$package_dir/*.jar" > /dev/null; then
      mapfile -t jar_files < <(ls $package_dir/*.jar 2>/dev/null)
    fi
    
    installer_jar=""
    has_installer_jar=false
    
    if [ "${#jar_files[@]}" -gt 0 ]; then
      if [ "${#jar_files[@]}" -gt 1 ]; then
        echo "Warning: Multiple JAR files found in $package_dir. Using the first one: $(basename ${jar_files[0]})"
      fi
      installer_jar="${jar_files[0]}"
      has_installer_jar=true
      echo "Found installer JAR: $(basename ${jar_files[0]})"
    fi
    
    # Initialize required files with Launcher binary
    required_files=("$package_dir/Launcher.run")
    
    # Process JRE files if available
    if [ "${#jre_files[@]}" -gt 0 ]; then
      jre_file="${jre_files[0]}"
      jre_version=$(get_jre_version "$(basename ${jre_files[0]})")
      echo "Found JRE/Java package: $(basename ${jre_files[0]}), version: $jre_version"
      required_files+=("$jre_file")
    else
      echo "No JRE/Java package found for $COMPONENT_TYPE."
    fi
    
    # Process Tomcat files if available
    if [ "${#tomcat_files[@]}" -gt 0 ]; then
      tomcat_file="${tomcat_files[0]}"
      tomcat_version=$(get_tomcat_version "$(basename ${tomcat_files[0]})")
      echo "Found Tomcat package: $(basename ${tomcat_files[0]}), version: $tomcat_version"
      required_files+=("$tomcat_file")
    else
      echo "No Tomcat package found for $COMPONENT_TYPE."
    fi
    
    # Add installer.jar to required files if it exists
    if [ "$has_installer_jar" = true ]; then
      required_files+=("$installer_jar")
    fi
  fi

  for file in "${required_files[@]}"; do
    if [ ! -f "$file" ]; then
      echo "Error: Required file not found: $file"
      exit 1
    fi
  done

  # Update file paths to use component-specific directory
  launcher_path="$package_dir/Launcher.run"
  # JRE and Tomcat files are already set in the dynamic detection code above
fi

# If this is an update in offline mode and we have an installer jar, copy it to the temp directory
if [ "$isUpdate" = true ] && [ "$offline_mode" = true ] && [ "$has_installer_jar" = true ]; then
    installerTempDir="$install_dir/installer/temp"
    
    # Create the temp directory if it doesn't exist
    if [ ! -d "$installerTempDir" ]; then
        echo "Creating installer temp directory: $installerTempDir"
        mkdir -p "$installerTempDir"
    fi
    
    # Copy the installer jar to the temp directory
    installerJarDest="$installerTempDir/installer.jar"
    echo "Copying installer JAR for offline update: $installer_jar -> $installerJarDest"
    if cp "$installer_jar" "$installerJarDest"; then
        echo "Successfully copied installer JAR for offline update"
    else
        echo "Warning: Failed to copy installer JAR for offline update"
    fi
fi

# Get hostname
hs=$(hostname)
if [ -z "$hs" ]; then
  echo "Warning: Could not read hostname. Falling back to manual input."
else
  echo "-------------------"
  echo "Hostname  : $hs"
  echo "==================="
fi

# Initialize variables for Store Number and Workstation ID
storeNumber=""
workstationId="${workstationId}"

# Priority 0: If CLI provided both values, skip detection
hostnameDetected=false
if [ -n "$storeId" ] && [ -n "$workstationId" ]; then
  storeNumber="$storeId"
  echo "Both Store ID and Workstation ID provided via CLI - skipping detection"
  hostnameDetected=true
fi

# For update mode, we must extract values from the existing installation
if [ "$isUpdate" = true ]; then
  echo "Running in update mode - attempting to extract store and workstation IDs from existing installation"
  
  # Look for station.properties in the installation directory
  station_properties_path="$install_dir/station.properties"
  if [ -f "$station_properties_path" ]; then
    echo "Found existing station.properties at: $station_properties_path"
    
    # Extract the store ID
    store_id_line=$(grep "station.storeId=" "$station_properties_path")
    if [ -n "$store_id_line" ]; then
      storeNumber=$(echo "$store_id_line" | cut -d'=' -f2)
      echo "Found Store ID in station.properties: $storeNumber"
    fi
    
    # Extract the workstation ID
    workstation_id_line=$(grep "station.workstationId=" "$station_properties_path")
    if [ -n "$workstation_id_line" ]; then
      workstationId=$(echo "$workstation_id_line" | cut -d'=' -f2)
      echo "Found Workstation ID in station.properties: $workstationId"
    fi
    
    # If both values were found, skip hostname detection
    if [ -n "$storeNumber" ] && [ -n "$workstationId" ]; then
      hostnameDetected=true
      echo "Using Store ID and Workstation ID from existing installation"
    else
      echo -e "\033[1;31mError: Could not extract complete information from station.properties\033[0m"
      echo -e "\033[1;31mUpdate not possible. Exiting.\033[0m"
      exit 1
    fi
  else
    echo -e "\033[1;31mError: No station.properties found at: $station_properties_path\033[0m"
    echo -e "\033[1;31mUpdate not possible. Exiting.\033[0m"
    exit 1
  fi
else
  # For new installations, detect from hostname or prompt user
  # Only run detection if at least one value is still missing
  if [ "$hostnameDetected" = false ] && [ -n "$hs" ]; then
    # Try different patterns:
    # 1. XXXX-YYY format (e.g., R005-101, 1674-101)
    # 2. SOMENAME-XXXX-YYY format (e.g., SOMENAME-1674-101)
    
    # Extract the last part (workstation ID)
    if [[ "$hs" =~ ([^-]+)-([0-9]+)$ ]]; then
      storeId="${BASH_REMATCH[1]}"
      workstationId="${BASH_REMATCH[2]}"
      
      # If storeId contains a dash, it might be SOMENAME-1674-101 format
      if [[ "$storeId" =~ .*-([0-9]{4})$ ]]; then
        storeNumber="${BASH_REMATCH[1]}"
      else
        # Direct format like R005-101
        storeNumber="$storeId"
      fi
      
      # Validate extracted parts
      # Accept any alphanumeric characters for store ID with at least 1 character
      if echo "$storeNumber" | grep -qE '^[A-Za-z0-9_\-\.]+$'; then
        if [[ "$workstationId" =~ ^[0-9]+$ ]]; then
          hostnameDetected=true
          echo "Successfully detected values from hostname:"
          echo "Store Number: $storeNumber"
          echo "Workstation ID: $workstationId"
        fi
      fi
    fi
  fi

  # If hostname detection failed, try file detection
  if [ "$hostnameDetected" = false ]; then
    if [ -n "$hs" ]; then
      echo "Could not extract valid Store Number and Workstation ID from hostname."
      echo "Trying file detection..."
    fi
    
    # File detection code will be inserted here by the generator
  fi

  # If both hostname and file detection failed, prompt for manual input
  # Only prompt for values that are still missing
  if [ "$hostnameDetected" = false ]; then
    echo "Falling back to manual input for missing values."
    
    # Prompt for Store Number only if not provided
    if [ -z "$storeNumber" ]; then
      echo "Please enter the Store Number in one of these formats (or any custom format):"
      echo "  - 4 digits (e.g., 1234)"
      echo "  - 1 letter + 3 digits (e.g., R005)"
      echo "  - 2 letters + 2 digits (e.g., CA45)"
      echo "  - Custom format (e.g., STORE-105)"
      read -p "Store Number: " storeNumber

      # Validate that something was entered
      if [ -z "$storeNumber" ]; then
        echo "Store Number cannot be empty. Please try again."
        read -p "Store Number: " storeNumber
      fi
    else
      echo "Store Number already provided: $storeNumber"
    fi
    
    # Prompt for Workstation ID only if not provided
    if [ -z "$workstationId" ]; then
      while true; do
        read -p "Please enter the Workstation ID (numeric): " workstationId
        if [[ "$workstationId" =~ ^[0-9]+$ ]]; then
          break
        fi
        echo "Invalid input. Please enter a numeric Workstation ID."
      done
    else
      echo "Workstation ID already provided: $workstationId"
    fi
  fi
fi

# Print final results
echo "-------------------"
echo "StoreNr   : $storeNumber"
echo "WorkstationId: $workstationId"
echo "-------------------"

# After the basic configuration section, update the onboarding call
echo "Starting onboarding process for $COMPONENT_TYPE"

# Skip onboarding and store initialization if this is an update
if [ "$isUpdate" = false ]; then
    # Call the onboarding script with the appropriate component type and tenant_id
    if ! ./onboarding.sh --ComponentType "$COMPONENT_TYPE" --base_url "$base_url" --tenant_id "$tenant_id"; then
      echo "Error during $COMPONENT_TYPE onboarding"
      exit 1
    fi
    echo "$COMPONENT_TYPE onboarding completed successfully"

    # Run store initialization for all components including WDM
    echo "Starting store initialization..."
    store_init_script="$PWD/store-initialization.sh"
    if [ -f "$store_init_script" ]; then
        # Update get_store.json with the store ID
        get_store_json_path="$PWD/helper/init/get_store.json"
        if [ -f "$get_store_json_path" ]; then
          echo "Creating processed copy of get_store.json with Store ID: $storeNumber"
          # Create a processed directory if it doesn't exist
          mkdir -p "$PWD/helper/init"
          # Create a processed copy
          processed_get_store_path="$PWD/helper/init/get_store_processed.json"
          # Copy the original to processed file
          cp "$get_store_json_path" "$processed_get_store_path"
          # Use sed to replace the placeholder with the actual store number in the processed copy
          sed -i "s/@RETAIL_STORE_ID@/$storeNumber/g" "$processed_get_store_path"
          echo "get_store_processed.json created successfully"
        else
          echo "Warning: get_store.json not found at: $get_store_json_path"
        fi

        # Update StoreHub configuration with dynamic version if this is a StoreHub installation
        if [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ]; then
          storehub_config_path="$PWD/helper/init/storehub/update_config.json"
          if [ -f "$storehub_config_path" ]; then
            echo "Updating StoreHub configuration with dynamic version: $component_version"
            # Create a backup of the original
            cp "$storehub_config_path" "$storehub_config_path.backup"
            # Create a processed copy with the dynamic version
            processed_storehub_config_path="$PWD/helper/init/storehub/update_config_processed.json"
            cp "$storehub_config_path" "$processed_storehub_config_path"
            # Replace the version placeholder with the dynamic version
            sed -i "s/@SYSTEM_VERSION@/$component_version/g" "$processed_storehub_config_path"
            echo "StoreHub configuration updated with version: $component_version"
          else
            echo "Warning: StoreHub config not found at: $storehub_config_path"
          fi
        fi

        # Call the store initialization script with the dynamic version
        if ! "$store_init_script" --ComponentType "$COMPONENT_TYPE" --base_url "$base_url" --StoreId "$storeNumber" --WorkstationId "$workstationId" --Version "$component_version"; then
          echo "Error during store initialization"
          exit 1
        fi
        echo "Store initialization completed successfully"
      else
        echo "Error: Store initialization script not found at: $store_init_script"
        exit 1
      fi
else
    echo "Skipping onboarding and store initialization for update"
fi

# Read onboarding token
onboardingToken=""
if [ "$isUpdate" = false ]; then
    onboardingTokenPath="onboarding.token"
    if [ ! -f "$onboardingTokenPath" ]; then
        echo "Error: Onboarding token file not found at: $onboardingTokenPath"
        exit 1
    fi
    onboardingToken=$(cat "$onboardingTokenPath" | tr -d '\n')
else
    echo "Skipping onboarding token check for update mode"
    onboardingToken="not-required-for-update"
fi

# Create configuration files
cat > "installationtoken.txt" << EOF
configService.url=https://$server/api/config
cims.url=https://$server/api/iam/cim/rest
station.tenantId=$tenant_id
station.storeId=$storeNumber
station.workstationId=$workstationId
station.applicationVersion=$component_version
station.systemType=$systemType
onboarding.token=$onboardingToken
dsg.url=https://$dsg_server/api/digital-content/content/cep/SoftwarePackage
EOF

# Create base64 token - ensure it's a single line without line breaks
base64Token=$(base64 -w 0 installationtoken.txt)
echo "$base64Token" > "installationtoken.base64"

# Create addonpack.properties
cat > "$install_dir/addonpack.properties" << EOF
dsg.addonpack.url=https://$dsg_server/dsg/content/cep/AddOnPacks
addonpacks=
EOF

# Only handle .p12 certificates for non-POS installations
if [ "$COMPONENT_TYPE" != "POS" ]; then
  # Handle .p12 file if it exists
  p12_files=()
  if compgen -G "*.p12" > /dev/null; then
    mapfile -t p12_files < <(ls *.p12 2>/dev/null)
  fi

  # Create security directory if it doesn't exist
  mkdir -p "$security_dir"

  # Check for certificates in the security directory
  security_p12_files=()
  if compgen -G "$security_dir/*.p12" > /dev/null; then
    mapfile -t security_p12_files < <(ls $security_dir/*.p12 2>/dev/null)
  fi

  ssl_path=""
  used_existing_cert=false

  # Check if we have certificates in current directory
fi
if [ "${#p12_files[@]}" -gt 0 ]; then
  echo "Found .p12 file(s) in script directory"
  
  # Check if we have certificates in security directory
  if [ "${#security_p12_files[@]}" -gt 0 ]; then
    echo "Found existing certificate(s) in security directory, checking for name matches..."
    
    # Check for name matches
    matching_cert=""
    for p12_file in "${p12_files[@]}"; do
      cert_name=$(basename "$p12_file")
      
      # Check if this certificate name exists in security directory
      for security_cert in "${security_p12_files[@]}"; do
        security_cert_name=$(basename "$security_cert")
        if [ "$cert_name" = "$security_cert_name" ]; then
          matching_cert="$security_cert"
          break 2  # Break out of both loops
        fi
      done
    done
    
    if [ -n "$matching_cert" ]; then
      # Use the matching certificate from security directory
      ssl_path="$matching_cert"
      echo "Using existing certificate with matching name: $(basename "$matching_cert") from security directory"
      used_existing_cert=true
    else
      # No matching certificate found, copy and use the new one
      echo "Certificate in current directory has different name than existing ones, copying and using new certificate"
      
      # Copy the first p12 file found if there are multiple
      new_cert="${p12_files[0]}"
      cert_name=$(basename "$new_cert")
      dest_path="$security_dir/$cert_name"
      echo "Copying $cert_name to $dest_path"
      cp "$new_cert" "$dest_path"
      
      # Use the newly copied certificate
      ssl_path="$dest_path"
    fi
  else
    # No certificates in security directory, copy all from current directory
    echo "No certificates in security directory, copying all from current directory"
    
    # Copy each .p12 file found
    for p12_file in "${p12_files[@]}"; do
      # Copy with original filename
      cert_name=$(basename "$p12_file")
      dest_path="$security_dir/$cert_name"
      echo "Copying $cert_name to $dest_path"
      cp "$p12_file" "$dest_path"
      
      # Set the ssl_path to the first certificate copied
      if [ -z "$ssl_path" ]; then
        ssl_path="$dest_path"
      fi
    done
  fi
elif [ "${#security_p12_files[@]}" -gt 0 ]; then
  # No certificates in current directory but some in security directory
  # Use the first .p12 file found in the security directory
  ssl_path="${security_p12_files[0]}"
  echo "Found certificate at: $ssl_path"
  used_existing_cert=true
else
  # No certificate found anywhere
  echo "Warning: No certificate found for Tomcat. The installation may fail if a certificate is required."
fi

# Paths
launchers_path="$PWD/helper/launchers"

# Verify launchers path exists
if [ ! -d "$launchers_path" ]; then
  echo "Launchers path does not exist: $launchers_path"
  exit 1
fi

# Select the appropriate template file
case "$COMPONENT_TYPE" in
  'POS')
    template_file="$launchers_path/launcher.pos.template"
    ;;
  'WDM')
    template_file="$launchers_path/launcher.wdm.template"
    ;;
  'FLOW-SERVICE')
    template_file="$launchers_path/launcher.flow-service.template"
    ;;
  'LPA-SERVICE')
    template_file="$launchers_path/launcher.lpa-service.template"
    ;;
  'STOREHUB-SERVICE')
    template_file="$launchers_path/launcher.storehub-service.template"
    ;;
  *)
    template_file="$launchers_path/launcher.wdm.template"
    ;;
esac

if [ ! -f "$template_file" ]; then
  echo "Error: Template file $template_file not found"
  exit 1
fi

# Read the template content
launcher_props=$(cat "$template_file")

# Replace placeholders with actual values
launcher_props="${launcher_props//@INSTALL_DIR@/$install_dir}"
launcher_props="${launcher_props//@BASE64_TOKEN@/$base64Token}"
launcher_props="${launcher_props//@OFFLINE_MODE@/$(if [ "$offline_mode" = true ]; then echo "1"; else echo "0"; fi)}"

if [ "$offline_mode" = true ] && [ -n "$jre_version" ]; then
  launcher_props="${launcher_props//@JRE_VERSION@/$jre_version}"
else
  launcher_props="${launcher_props//@JRE_VERSION@/}"
fi

if [ "$offline_mode" = true ] && [ "${#jre_files[@]}" -gt 0 ]; then
  launcher_props="${launcher_props//@JRE_PACKAGE@/$PWD\/${jre_files[0]}}"
else
  launcher_props="${launcher_props//@JRE_PACKAGE@/}"
fi

if [ "$offline_mode" = true ] && [ "$has_installer_jar" = true ]; then
  launcher_props="${launcher_props//@INSTALLER_PACKAGE@/$installer_jar}"
else
  launcher_props="${launcher_props//@INSTALLER_PACKAGE@/}"
fi

launcher_props="${launcher_props//@SSL_PATH@/$ssl_path}"
launcher_props="${launcher_props//@SSL_PASSWORD@/$ssl_password}"

# For StoreHub, set the Firebird server path
# Ensure the path is clean before replacing
if [[ "$COMPONENT_TYPE" == "STOREHUB-SERVICE" ]]; then
  # Instead of using string replacement, we'll directly modify the launcher.properties content
  # by removing the existing line and adding a new one
  launcher_props=$(echo "$launcher_props" | grep -v "firebirdServerPath=")
  launcher_props="${launcher_props}"$'\n'"firebirdServerPath=$firebird_server_path"
  
  # Add the Jaybird path only if it was detected
  if [ "$has_jaybird" = true ]; then
    launcher_props=$(echo "$launcher_props" | grep -v "firebird_driver_path_local=")
    launcher_props="${launcher_props}"$'\n'"firebird_driver_path_local=$firebird_driver_path_local"
    echo "Added detected Jaybird driver path to launcher.properties: $firebird_driver_path_local"
  fi
fi
launcher_props="${launcher_props//@FIREBIRD_DRIVER_PATH_LOCAL@/$firebird_driver_path_local}"

# Add Tomcat replacements if Tomcat files were found
if [ "${#tomcat_files[@]}" -gt 0 ]; then
  if [ "$offline_mode" = true ]; then
    launcher_props="${launcher_props//@TOMCAT_VERSION@/$tomcat_version}"
    launcher_props="${launcher_props//@TOMCAT_PACKAGE@/$PWD\/${tomcat_files[0]}}"
  else
    launcher_props="${launcher_props//@TOMCAT_VERSION@/}"
    launcher_props="${launcher_props//@TOMCAT_PACKAGE@/}"
  fi
fi

echo "Writing launcher properties to file..."
echo "$launcher_props" > "launcher.properties"
echo "Launcher properties file created successfully. Launcher will use this for configuration."

# Download or use local Launcher
if [ "$offline_mode" = false ]; then
    download_url="https://$base_url/dsg/content/cep/SoftwarePackage/$systemType/$component_version/Launcher.run"
  echo "Attempting to download Launcher.run from: $download_url"
  
  # Try using curl with progress bar first
  if command -v curl >/dev/null 2>&1; then
    echo "Using curl for download with progress bar..."
    if curl -L --progress-bar -o "Launcher.run" "$download_url"; then
      if [ -f "Launcher.run" ] && [ -s "Launcher.run" ]; then
        echo "Successfully downloaded Launcher.run using curl"
      else
        echo "Curl download produced empty file. Trying wget..."
        if command -v wget >/dev/null 2>&1; then
          echo "Using wget as fallback..."
          if wget --show-progress -O "Launcher.run" "$download_url"; then
            echo "Successfully downloaded Launcher.run using wget"
          else
            echo "Error downloading Launcher.run"
            exit 1
          fi
        else
          echo "Error downloading: Empty file and wget not available"
          exit 1
        fi
      fi
    else
      # Try wget as a fallback
      echo "Curl failed. Trying wget..."
      if command -v wget >/dev/null 2>&1; then
        echo "Using wget as fallback..."
        if wget --show-progress -O "Launcher.run" "$download_url"; then
          echo "Successfully downloaded Launcher.run using wget"
        else
          echo "Error downloading Launcher.run"
          exit 1
        fi
      else
        echo "Error downloading: Curl failed and wget not available"
        exit 1
      fi
    fi
  elif command -v wget >/dev/null 2>&1; then
    # No curl, use wget directly
    echo "Using wget for download with progress bar..."
    if wget --show-progress -O "Launcher.run" "$download_url"; then
      echo "Successfully downloaded Launcher.run using wget"
    else
      echo "Error downloading Launcher.run"
      exit 1
    fi
  else
    echo "Error: Neither curl nor wget is available for downloading"
    exit 1
  fi
  
  chmod +x "./Launcher.run"
else
  # In offline mode, copy the Launcher from the package directory to the current directory
  echo "Copying Launcher.run from $package_dir to current directory..."
  if ! cp "$launcher_path" "./Launcher.run"; then
    echo "Error copying Launcher.run"
    exit 1
  fi
  echo "Successfully copied Launcher.run"
  chmod +x "./Launcher.run"
fi

# Start the installation
echo "Starting installation..."

# Check if installer log already exists and delete it
installer_log_path="$install_dir/installer/log/installer.log"
if [ -f "$installer_log_path" ]; then
  echo "Found existing installer log file. Deleting to ensure clean installation..."
  rm -f "$installer_log_path" 2>/dev/null
  if [ $? -eq 0 ]; then
    echo "Existing installer log file deleted successfully."
  else
    echo "Warning: Failed to delete existing installer log file."
    echo "This might lead to confusing log output during installation."
  fi
fi

echo "Running Launcher.run with arguments: --defaultsFile launcher.properties --mode unattended"

# If we found JRE, add it to PATH temporarily to ensure Java can be found

# Start Launcher based on whether this is an update or new installation
if [ "$isUpdate" = true ]; then
    echo -e "\033[1;36m=================================================================\033[0m"
    echo -e "\033[1;36m                     RUNNING IN UPDATE MODE                      \033[0m"
    echo -e "\033[1;36m=================================================================\033[0m"
    echo "Running Launcher with update arguments: --mode unattended --forceDownload false --station.applicationVersion $component_version --station.propertiesPath $install_dir"
    ./Launcher.run --mode unattended --forceDownload false --station.applicationVersion "$component_version" --station.propertiesPath "$install_dir" &
    launcher_pid=$!
else
    echo -e "\033[1;32m=================================================================\033[0m"
    echo -e "\033[1;32m                 RUNNING IN FULL INSTALLATION MODE               \033[0m"
    echo -e "\033[1;32m=================================================================\033[0m"
    ./Launcher.run --defaultsFile launcher.properties --mode unattended &
    launcher_pid=$!
fi

# Check installation logs
max_wait_time=7200 # 2 hours timeout
max_log_wait_time=3600 # 1 hour timeout for files download from DSG
elapsed=0
log_wait_elapsed=0
check_interval=2 # Check every 2 seconds
last_line_number=0
first_log=true

echo "Waiting for installation to complete..."
echo "Monitoring log: $installer_log_path"

while [ $elapsed -lt $max_wait_time ]; do
  # Check if launcher is still running
  if ! kill -0 $launcher_pid 2>/dev/null; then
    launcher_exit_code=$?
    echo "Launcher process has exited with code: $launcher_exit_code"
    echo "Continuing to monitor logs for 5 seconds..."
    
    post_exit_time=5
    while [ $post_exit_time -gt 0 ]; do
      if [ -f "$installer_log_path" ]; then
        # Read new lines from the log
        current_content=$(cat "$installer_log_path" 2>/dev/null || echo "")
        current_line_count=$(echo "$current_content" | wc -l)
        
        if [ $current_line_count -gt $last_line_number ]; then
          new_lines=$(echo "$current_content" | tail -n $((current_line_count - last_line_number)))
          echo "$new_lines" | while read -r line; do
            echo "LOG: $line"
          done
          last_line_number=$current_line_count
        fi
      fi
      
      echo -n -e "\rTime remaining for log monitoring: $post_exit_time seconds..."
      sleep 1
      post_exit_time=$((post_exit_time - 1))
    done
    echo -e "\nCompleting installation..."
    
    # Final log check
    if [ -f "$installer_log_path" ]; then
      final_log_content=$(tail -n 20 "$installer_log_path" 2>/dev/null || echo "")
      
      if echo "$final_log_content" | grep -q "Installation finished"; then
        echo "Installation completed successfully!"
        echo "Installation directory: $install_dir"
        
        # Component-specific completion messages
        echo "$COMPONENT_TYPE installation has been completed successfully."
        
        # Cleanup: Move generated files to a results directory
        results_dir="results_$COMPONENT_TYPE"
        echo "Performing cleanup - Moving generated files to $results_dir directory..."
        
        # Create the results directory if it doesn't exist
        mkdir -p "$results_dir"
        
        # List of files to move
        files_to_move=(
          "installationtoken.txt"
          "installationtoken.base64"
          "launcher.properties"
          "onboarding.token"
          "Launcher.run"
        )
        
        # Add log files
        log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
        # Only add log files if they actually exist
        if [ -n "$log_files" ]; then
          for log_file in $log_files; do
            if [ -f "$log_file" ]; then
              files_to_move+=("$log_file")
            fi
          done
        fi
        
        # Find all JSON files in the current directory only
        json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
        if [ -n "$json_files" ]; then
          echo "Found JSON files to move"
          for json_file in $json_files; do
            files_to_move+=("$json_file")
          done
        else
          echo "No JSON files need to be cleaned up"
        fi
        
        # Move each file to the results directory
        for file in "${files_to_move[@]}"; do
          if [ -f "$file" ]; then
            # Skip files in helper directory
            if [[ "$file" == *"/helper/"* ]]; then
              continue
            fi
            
            # Process only files in current directory
            filename=$(basename "$file")
            dest_file="$results_dir/$filename"
            
            # Copy file to results directory then remove original
            cp "$file" "$dest_file" 2>/dev/null
            if [ $? -eq 0 ]; then
              echo "Moved: $file to $dest_file"
              rm "$file"
            else
              echo "Warning: Could not move $file to results directory"
            fi
          fi
        done
        
        # Make sure the log file is moved to results directory at the end
        if [ -f "$log_file" ]; then
            dest_log_file="$results_dir/$log_file"
            cp "$log_file" "$dest_log_file" 2>/dev/null
            if [ $? -eq 0 ]; then
                echo "Console output log saved to: $dest_log_file"
                rm "$log_file"
            else
                echo "Warning: Could not move log file to results directory"
            fi
        fi

        echo "Cleanup completed. Installation files have been moved to $results_dir directory."

        # Clean up access token
        rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

        exit 0
      elif echo "$final_log_content" | grep -q "Installation failed"; then
        echo "Installation failed. Please check the logs at: $installer_log_path"

        # Clean up access token
        rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

        exit 1
      fi
    fi
    
    # If we couldn't determine status from logs, use process exit code
    if [ $launcher_exit_code -eq 0 ]; then
      echo "Launcher completed successfully based on exit code."
      echo "Installation directory: $install_dir"
      
      # Cleanup: Move generated files to a results directory
      results_dir="results_$COMPONENT_TYPE"
      echo "Performing cleanup - Moving generated files to $results_dir directory..."
      
      # Create the results directory if it doesn't exist
      mkdir -p "$results_dir"
      
      # List of files to move
      files_to_move=(
        "installationtoken.txt"
        "installationtoken.base64"
        "launcher.properties"
        "onboarding.token"
        "Launcher.run"
      )
      
      # Add log files
      log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
      # Only add log files if they actually exist
      if [ -n "$log_files" ]; then
        for log_file in $log_files; do
          if [ -f "$log_file" ]; then
            files_to_move+=("$log_file")
          fi
        done
      fi
      
      # Find all JSON files in the current directory only
      json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
      if [ -n "$json_files" ]; then
        echo "Found JSON files to move"
        for json_file in $json_files; do
          files_to_move+=("$json_file")
        done
      else
        echo "No JSON files need to be cleaned up"
      fi
      
      # Move each file to the results directory
      for file in "${files_to_move[@]}"; do
        if [ -f "$file" ]; then
          # Skip files in helper directory
          if [[ "$file" == *"/helper/"* ]]; then
            continue
          fi
          
          # Process only files in current directory
          filename=$(basename "$file")
          dest_file="$results_dir/$filename"
          
          # Copy file to results directory then remove original
          cp "$file" "$dest_file" 2>/dev/null
          if [ $? -eq 0 ]; then
            echo "Moved: $file to $dest_file"
            rm "$file"
          else
            echo "Warning: Could not move $file to results directory"
          fi
        fi
      done

      # Make sure the log file is moved to results directory at the end
      if [ -f "$log_file" ]; then
          dest_log_file="$results_dir/$log_file"
          cp "$log_file" "$dest_log_file" 2>/dev/null
          if [ $? -eq 0 ]; then
              echo "Console output log saved to: $dest_log_file"
              rm "$log_file"
          else
              echo "Warning: Could not move log file to results directory"
          fi
      fi

      echo "Cleanup completed. Installation files have been moved to $results_dir directory."

      # Clean up access token
      rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

      exit 0
    else
      echo "Launcher failed with exit code: $launcher_exit_code"
      echo "Please check the logs at: $installer_log_path"
      
      # Cleanup for failed installation
      errors_dir="errors_$COMPONENT_TYPE"
      echo "Performing cleanup for failed installation - Moving files to $errors_dir directory..."
      
      # Create the errors directory if it doesn't exist
      mkdir -p "$errors_dir"
      
      # List of files to move
      files_to_move=(
        "installationtoken.txt"
        "installationtoken.base64"
        "launcher.properties"
        "onboarding.token"
        "Launcher.run"
      )
      
      # Add log files
      log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
      # Only add log files if they actually exist
      if [ -n "$log_files" ]; then
        for log_file in $log_files; do
          if [ -f "$log_file" ]; then
            files_to_move+=("$log_file")
          fi
        done
      fi
      
      # Find all JSON files in the current directory only
      json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
      if [ -n "$json_files" ]; then
        echo "Found JSON files to move"
        for json_file in $json_files; do
          files_to_move+=("$json_file")
        done
      else
        echo "No JSON files need to be cleaned up"
      fi
      
      # Move each file to the errors directory
      for file in "${files_to_move[@]}"; do
        if [ -f "$file" ]; then
          # Skip files in helper directory
          if [[ "$file" == *"/helper/"* ]]; then
            continue
          fi
          
          # Process only files in current directory
          filename=$(basename "$file")
          dest_file="$errors_dir/$filename"
          
          # Copy file to errors directory then remove original
          cp "$file" "$dest_file" 2>/dev/null
          if [ $? -eq 0 ]; then
            echo "Moved: $file to $dest_file"
            rm "$file"
          else
            echo "Warning: Could not move $file to errors directory"
          fi
        fi
      done
      
      # Make sure the log file is moved to errors directory at the end
      if [ -f "$log_file" ]; then
          dest_log_file="$errors_dir/$log_file"
          cp "$log_file" "$dest_log_file" 2>/dev/null
          if [ $? -eq 0 ]; then
              echo "Console output log saved to: $dest_log_file"
              rm "$log_file"
          else
              echo "Warning: Could not move log file to errors directory"
          fi
      fi

      echo "Cleanup completed. Failed installation files have been moved to $errors_dir directory."

      # Clean up access token
      rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

      exit 1
    fi
  fi

  if [ -f "$installer_log_path" ]; then
    # First time we see the log file
    if [ "$first_log" = true ]; then
      echo "Log file created at: $installer_log_path"
      first_log=false
    fi

    # Read new lines from the log
    current_content=$(cat "$installer_log_path" 2>/dev/null || echo "")
    current_line_count=$(echo "$current_content" | wc -l)
    
    if [ $current_line_count -gt $last_line_number ]; then
      new_lines=$(echo "$current_content" | tail -n $((current_line_count - last_line_number)))
      echo "$new_lines" | while read -r line; do
        echo "LOG: $line"
      done
      last_line_number=$current_line_count
    fi

    # Check for completion
    log_content=$(tail -n 20 "$installer_log_path" 2>/dev/null || echo "")
    
    if echo "$log_content" | grep -q "Installation finished"; then
      echo "Installation completed successfully!"
      echo "Installation directory: $install_dir"
      
      # Component-specific completion messages
      echo "$COMPONENT_TYPE installation has been completed successfully."
      
      # Kill the launcher process if it's still running
      if kill -0 $launcher_pid 2>/dev/null; then
        kill $launcher_pid
      fi
      
      # Cleanup: Move generated files to a results directory
      results_dir="results_$COMPONENT_TYPE"
      echo "Performing cleanup - Moving generated files to $results_dir directory..."
      
      # Create the results directory if it doesn't exist
      mkdir -p "$results_dir"
      
      # List of files to move
      files_to_move=(
        "installationtoken.txt"
        "installationtoken.base64"
        "launcher.properties"
        "onboarding.token"
        "Launcher.run"
      )
      
      # Add log files
      log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
      # Only add log files if they actually exist
      if [ -n "$log_files" ]; then
        for log_file in $log_files; do
          if [ -f "$log_file" ]; then
            files_to_move+=("$log_file")
          fi
        done
      fi
      
      # Find all JSON files in the current directory only
      json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
      if [ -n "$json_files" ]; then
        echo "Found JSON files to move"
        for json_file in $json_files; do
          files_to_move+=("$json_file")
        done
      else
        echo "No JSON files need to be cleaned up"
      fi
      
      # Move each file to the results directory
      for file in "${files_to_move[@]}"; do
        if [ -f "$file" ]; then
          # Skip files in helper directory
          if [[ "$file" == *"/helper/"* ]]; then
            continue
          fi
          
          # Process only files in current directory
          filename=$(basename "$file")
          dest_file="$results_dir/$filename"
          
          # Copy file to results directory then remove original
          cp "$file" "$dest_file" 2>/dev/null
          if [ $? -eq 0 ]; then
            echo "Moved: $file to $dest_file"
            rm "$file"
          else
            echo "Warning: Could not move $file to results directory"
          fi
        fi
      done

      # Make sure the log file is moved to results directory at the end
      if [ -f "$log_file" ]; then
          dest_log_file="$results_dir/$log_file"
          cp "$log_file" "$dest_log_file" 2>/dev/null
          if [ $? -eq 0 ]; then
              echo "Console output log saved to: $dest_log_file"
              rm "$log_file"
          else
              echo "Warning: Could not move log file to results directory"
          fi
      fi

      echo "Cleanup completed. Installation files have been moved to $results_dir directory."

      # Clean up access token
      rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

      exit 0
    elif echo "$log_content" | grep -q "Installation failed"; then
      echo "Installation failed. Please check the logs at: $installer_log_path"
      
      # Kill the launcher process if it's still running
      if kill -0 $launcher_pid 2>/dev/null; then
        kill $launcher_pid
      fi
      
      # Cleanup for failed installation
      errors_dir="errors_$COMPONENT_TYPE"
      echo "Performing cleanup for failed installation - Moving files to $errors_dir directory..."
      
      # Create the errors directory if it doesn't exist
      mkdir -p "$errors_dir"
      
      # List of files to move
      files_to_move=(
        "installationtoken.txt"
        "installationtoken.base64"
        "launcher.properties"
        "onboarding.token"
        "Launcher.run"
      )
      
      # Add log files
      log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
      # Only add log files if they actually exist
      if [ -n "$log_files" ]; then
        for log_file in $log_files; do
          if [ -f "$log_file" ]; then
            files_to_move+=("$log_file")
          fi
        done
      fi
      
      # Find all JSON files in the current directory only
      json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
      if [ -n "$json_files" ]; then
        echo "Found JSON files to move"
        for json_file in $json_files; do
          files_to_move+=("$json_file")
        done
      else
        echo "No JSON files need to be cleaned up"
      fi
      
      # Move each file to the errors directory
      for file in "${files_to_move[@]}"; do
        if [ -f "$file" ]; then
          # Skip files in helper directory
          if [[ "$file" == *"/helper/"* ]]; then
            continue
          fi
          
          # Process only files in current directory
          filename=$(basename "$file")
          dest_file="$errors_dir/$filename"
          
          # Copy file to errors directory then remove original
          cp "$file" "$dest_file" 2>/dev/null
          if [ $? -eq 0 ]; then
            echo "Moved: $file to $dest_file"
            rm "$file"
          else
            echo "Warning: Could not move $file to errors directory"
          fi
        fi
      done
      
      # Make sure the log file is moved to errors directory at the end
      if [ -f "$log_file" ]; then
          dest_log_file="$errors_dir/$log_file"
          cp "$log_file" "$dest_log_file" 2>/dev/null
          if [ $? -eq 0 ]; then
              echo "Console output log saved to: $dest_log_file"
              rm "$log_file"
          else
              echo "Warning: Could not move log file to errors directory"
          fi
      fi

      echo "Cleanup completed. Failed installation files have been moved to $errors_dir directory."

      # Clean up access token
      rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

      exit 1
    fi
  else
    if [ "$offline_mode" = false ]; then
      echo "Waiting for installer log file to be created... ($log_wait_elapsed seconds elapsed) - Downloading installation files from $base_url DSG"
    else
      echo "Waiting for installer log file to be created... ($log_wait_elapsed seconds elapsed)"
    fi
    log_wait_elapsed=$((log_wait_elapsed + check_interval))
    if [ $log_wait_elapsed -ge $max_log_wait_time ]; then
      echo "Error: Timeout waiting for installer log file to be created after $((max_log_wait_time/60)) minutes"
      echo "Expected log path: $installer_log_path"
      # Try to kill launcher process if it's still running
      if kill -0 $launcher_pid 2>/dev/null; then
        echo "Terminating launcher process..."
        kill $launcher_pid
      fi

      # Clean up access token
      rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

      exit 1
    fi
  fi
  
  sleep $check_interval
  elapsed=$((elapsed + check_interval))
  
  # Show progress less frequently
  if [ $((elapsed % 30)) -eq 0 ]; then
    echo "Installation in progress... ($((elapsed / 60)) minutes elapsed)"
  fi
done

# Try to kill launcher process if it's still running after timeout
if kill -0 $launcher_pid 2>/dev/null; then
  echo "Terminating launcher process due to timeout..."
  kill $launcher_pid
fi

echo "Warning: Installation timeout reached after 2 hours. Please check the installation logs at: $installer_log_path"
echo "Installation directory: $install_dir"

# Cleanup for timeout failure
errors_dir="errors_$COMPONENT_TYPE"
echo "Performing cleanup for timed out installation - Moving files to $errors_dir directory..."

# Create the errors directory if it doesn't exist
mkdir -p "$errors_dir"

# List of files to move
files_to_move=(
  "installationtoken.txt"
  "installationtoken.base64"
  "launcher.properties"
  "onboarding.token"
  "Launcher.run"
)

# Add log files
log_files=$(find . -maxdepth 1 -name "*.log" -type f 2>/dev/null || echo "")
# Only add log files if they actually exist
if [ -n "$log_files" ]; then
  for log_file in $log_files; do
    if [ -f "$log_file" ]; then
      files_to_move+=("$log_file")
    fi
  done
fi

# Find all JSON files in the current directory only
json_files=$(find . -maxdepth 1 -name "*.json" -type f 2>/dev/null || echo "")
if [ -n "$json_files" ]; then
  echo "Found JSON files to move"
  for json_file in $json_files; do
    files_to_move+=("$json_file")
  done
else
  echo "No JSON files need to be cleaned up"
fi

# Move each file to the errors directory
for file in "${files_to_move[@]}"; do
  if [ -f "$file" ]; then
    # Skip files in helper directory
    if [[ "$file" == *"/helper/"* ]]; then
      continue
    fi
    
    # Process only files in current directory
    filename=$(basename "$file")
    dest_file="$errors_dir/$filename"
    
    # Copy file to errors directory then remove original
    cp "$file" "$dest_file" 2>/dev/null
    if [ $? -eq 0 ]; then
      echo "Moved: $file to $dest_file"
      rm "$file"
    else
      echo "Warning: Could not move $file to errors directory"
    fi
  fi
done

# Make sure the log file is moved to errors directory at the end
if [ -f "$log_file" ]; then
    dest_log_file="$errors_dir/$log_file"
    cp "$log_file" "$dest_log_file" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "Console output log saved to: $dest_log_file"
        rm "$log_file"
    else
        echo "Warning: Could not move log file to errors directory"
    fi
fi

echo "Cleanup completed. Timed out installation files have been moved to $errors_dir directory."

# Clean up access token
rm -f "$PWD/helper/tokens/access_token.txt" 2>/dev/null

exit 1 

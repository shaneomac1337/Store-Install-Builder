param(
    [switch]$offline,
    [ValidateSet('POS', 'ONEX', 'ONEX-POS', 'WDM', 'FLOW-SERVICE', 'LPA', 'SH', 'LPA-SERVICE', 'STOREHUB-SERVICE', 'RCS', 'RCS-SERVICE')]
    [string]$ComponentType = 'POS',
    [string]$base_url = "test.cse.cloud4retail.co",
    [string]$storeId,  # Optional: Override Store ID detection
    [string]$WorkstationId,  # Optional: Override Workstation ID detection
    [bool]$UseDefaultVersions = @USE_DEFAULT_VERSIONS@,
    [string]$VersionSource = "@VERSION_SOURCE@",  # FP or CONFIG
    [string]$Env,  # Environment alias for multi-environment support (e.g., P, DEV, Q-001)
    [Alias('Environment')]
    [string]$EnvironmentName,  # Alternative parameter name for -Environment
    [switch]$noOverrides,  # Skip deploying installer override files
    [switch]$skipCheckAlive,  # Override: skip check-alive even if XML says otherwise
    [switch]$skipStartApplication,  # Override: skip start-application even if XML says otherwise
    [switch]$ListEnvironments,  # List available environments and exit
    [string]$rcsUrl  # Optional: RCS URL for installation token (e.g., http://10.63.2.215:8080/rcs)
)

# Create a unique log filename based on timestamp
$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$logFile = "GKInstall_$ComponentType`_$timestamp.log"

# Start transcript to capture all console output
try {
    Start-Transcript -Path $logFile -Append
    Write-Host "Console output is being saved to $logFile"
} catch {
    Write-Host "Warning: Unable to start transcript. Console output will not be saved to a log file."
    Write-Host "Error: $_"
}

# Define function to ensure transcript is stopped
function Stop-TranscriptSafely {
    # Simplified approach - just call Stop-Transcript directly
    try {
        Stop-Transcript -ErrorAction SilentlyContinue
    } catch {
        # Ignore errors
    }
}

# Trap for terminating errors (exceptions)
trap {
    Stop-TranscriptSafely
    break
}

# Handle CTRL+C (SIGINT) to stop transcript
$null = Register-EngineEvent -SourceIdentifier Console_CancelKeyPress -Action {
    Write-Host "CTRL+C detected, stopping transcript and exiting..."
    Stop-TranscriptSafely
    exit 1
}

# Set TLS 1.2 as the security protocol (fixes SSL/TLS errors on older systems)
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12

# Set certificate validation to always return true (bypass SSL validation)
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}

# Stop on first error
$ErrorActionPreference = "Stop"

# Map shortened component types to full names
if ($ComponentType -eq 'ONEX') {
    $ComponentType = 'ONEX-POS'
} elseif ($ComponentType -eq 'LPA') {
    $ComponentType = 'LPA-SERVICE'
} elseif ($ComponentType -eq 'SH') {
    $ComponentType = 'STOREHUB-SERVICE'
} elseif ($ComponentType -eq 'RCS') {
    $ComponentType = 'RCS-SERVICE'
}

# Clean up any stale access token from previous runs
$tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
if (Test-Path $tokenPath) {
    try {
        Remove-Item -Path $tokenPath -Force -ErrorAction Stop
        Write-Host "Cleaned up stale access token from previous installation"
    } catch {
        Write-Host "Warning: Could not remove stale access token: $_"
    }
}

# Clean up environment-specific username file to prevent contamination
$formUsernamePath = Join-Path $PSScriptRoot "helper\tokens\form_username.txt"
if (Test-Path $formUsernamePath) {
    try {
        Remove-Item -Path $formUsernamePath -Force -ErrorAction Stop
        Write-Host "Cleaned up stale form username from previous installation"
    } catch {
        Write-Host "Warning: Could not remove stale form username: $_"
    }
}

# Function for error handling
function Handle-Error {
    param($LineNumber)
    Write-Host "Error occurred at line $LineNumber"
    Stop-TranscriptSafely
    exit 1
}

# Function to load environments from environments.json
function Load-Environments {
    $envFile = Join-Path $PSScriptRoot "helper\environments\environments.json"
    if (Test-Path $envFile) {
        try {
            $raw = Get-Content $envFile -Raw | ConvertFrom-Json
            # Normalize to an object with an 'environments' array regardless of file shape
            if ($null -ne $raw -and ($raw.PSObject.Properties.Name -contains 'environments')) {
                return $raw
            } elseif ($raw -is [System.Collections.IEnumerable]) {
                # Create a PSCustomObject instead of hashtable for consistency
                return [PSCustomObject]@{ environments = @($raw) }
            } else {
                return [PSCustomObject]@{ environments = @() }
            }
        } catch {
            Write-Host "Warning: Failed to load environments.json: $_"
            return [PSCustomObject]@{ environments = @() }
        }
    }
    return [PSCustomObject]@{ environments = @() }
}

# Function to list available environments
function Show-Environments {
    $envData = Load-Environments
    # Check if envData has 'environments' property (works for both PSCustomObject and parsed JSON)
    if ($null -ne $envData -and (Get-Member -InputObject $envData -Name 'environments' -MemberType Properties)) {
        $envList = $envData.environments
    } else {
        $envList = @()
    }
    if ($envList.Count -eq 0) {
        Write-Host "No environments configured."
        return
    }
    
    Write-Host "`n=== Available Environments ==="
    Write-Host "Alias`t`tName`t`t`tBase URL"
    Write-Host "-----`t`t----`t`t`t--------"
    foreach ($environment in $envList) {
        Write-Host "$($environment.alias)`t`t$($environment.name)`t`t$($environment.base_url)"
    }
    Write-Host "`nUse: .\GKInstall.ps1 -Env <alias> -ComponentType <type>"
    Write-Host "Example: .\GKInstall.ps1 -Env P -ComponentType POS`n"
}

# Function to select environment based on priority: CLI > hostname > file > prompt
function Select-Environment {
    param(
        [string]$EnvAlias,
        [string]$EnvName
    )
    
    $envData = Load-Environments
    # Check if envData has 'environments' property (works for both PSCustomObject and parsed JSON)
    if ($null -ne $envData -and (Get-Member -InputObject $envData -Name 'environments' -MemberType Properties)) {
        $environments = $envData.environments
    } else {
        $environments = @()
    }
    if ($environments.Count -eq 0) {
        Write-Host "No multi-environment configuration found, using default settings."
        return $null
    }
    
    Write-Host "`n=== Multi-Environment Mode ==="
    Write-Host "Found $($environments.Count) configured environment(s)"
    
    $selectedEnv = $null
    
    # Priority 1: CLI parameter
    if (![string]::IsNullOrWhiteSpace($EnvAlias)) {
        Write-Host "[1] CLI Parameter: Looking for environment '$EnvAlias'..."
        $selectedEnv = $environments | Where-Object { $_.alias -eq $EnvAlias } | Select-Object -First 1
        if ($selectedEnv) {
            Write-Host "    [OK] Found: $($selectedEnv.name) ($($selectedEnv.base_url))"
            return $selectedEnv
        } else {
            Write-Host "    [X] Environment '$EnvAlias' not found!"
            Write-Host ""
            Show-Environments
            exit 1
        }
    }
    
    if (![string]::IsNullOrWhiteSpace($EnvName)) {
        Write-Host "[1] CLI Parameter: Looking for environment named '$EnvName'..."
        $selectedEnv = $environments | Where-Object { $_.name -like "*$EnvName*" } | Select-Object -First 1
        if ($selectedEnv) {
            Write-Host "    [OK] Found: $($selectedEnv.name) ($($selectedEnv.base_url))"
            return $selectedEnv
        }
    }
    
    # HOSTNAME_ENV_DETECTION_PLACEHOLDER
    
    # Priority 2: Environment file detection from .station files
    $fileDetectionEnabled = "@FILE_DETECTION_ENABLED@"
    if ($fileDetectionEnabled -eq "True") {
        Write-Host "[2] File Detection: Checking for environment in .station file..."
        
        # Determine station filename based on component type
        $station_filename = switch ($ComponentType) {
        'POS' { "POS.station" }
        'ONEX-POS' { "ONEX.station" }
        'WDM' { "WDM.station" }
        'FLOW-SERVICE' { "FLOW-SERVICE.station" }
        'LPA-SERVICE' { "LPA.station" }
        'STOREHUB-SERVICE' { "SH.station" }
        'RCS-SERVICE' { "RCS.station" }
        default { $null }
    }
    
    if ($station_filename) {
        $stations_dir = "C:\gkretail\stations"
        $station_file = Join-Path $stations_dir $station_filename
        
        if (Test-Path $station_file) {
            Write-Host "    Checking station file: $station_file"
            $station_content = Get-Content $station_file -Raw -ErrorAction SilentlyContinue
            
            if ($station_content -and $station_content -match 'Environment=([^\r\n]+)') {
                $fileEnv = $matches[1].Trim()
                Write-Host "    Found Environment=$fileEnv in station file"
                $selectedEnv = $environments | Where-Object { $_.alias -eq $fileEnv } | Select-Object -First 1
                if ($selectedEnv) {
                    Write-Host "    [OK] Matched: $($selectedEnv.name) ($($selectedEnv.base_url))"
                    return $selectedEnv
                } else {
                    Write-Host "    [X] ERROR: Environment '$fileEnv' found in station file but not configured!"
                    Write-Host ""
                    Show-Environments
                    Write-Host ""
                    Write-Host "Please add environment '$fileEnv' to your configuration or fix the station file."
                    exit 1
                }
            } else {
                Write-Host "    No Environment= line found in station file"
            }
        } else {
            Write-Host "    Station file not found: $station_file"
        }
    } else {
        Write-Host "    ComponentType not yet determined, skipping station file check"
    }
    } else {
        Write-Host "[2] File Detection: Disabled - skipping environment detection from station files"
    }
    
    # Priority 3: Interactive prompt - always offer choice between configured environment(s) and default
    Write-Host "[3] Interactive Selection: Please choose an environment"
    Write-Host ""
    Write-Host "  [0] Use Default (from main configuration)"
    for ($i = 0; $i -lt $environments.Count; $i++) {
        $env = $environments[$i]
        Write-Host "  [$($i+1)] $($env.alias) - $($env.name) ($($env.base_url))"
    }
    Write-Host ""
    
    while ($true) {
        $selection = Read-Host "Enter number (0 for default, 1-$($environments.Count) for environment)"
        $selectionNum = 0
        if ([int]::TryParse($selection, [ref]$selectionNum)) {
            if ($selectionNum -eq 0) {
                Write-Host "    [OK] Using default configuration"
                return $null
            }
            if ($selectionNum -ge 1 -and $selectionNum -le $environments.Count) {
                $selectedEnv = $environments[$selectionNum - 1]
                Write-Host "    [OK] Selected: $($selectedEnv.name) ($($selectedEnv.base_url))"
                return $selectedEnv
            }
        }
        Write-Host "Invalid selection, please try again."
    }
}

# Function to apply environment configuration
function Apply-EnvironmentConfig {
    param($Environment)
    
    if ($null -eq $Environment) {
        return
    }
    
    Write-Host "`n=== Applying Environment Configuration ==="
    Write-Host "Environment: $($Environment.name) ($($Environment.alias))"
    Write-Host "Base URL: $($Environment.base_url)"
    Write-Host "Tenant ID: $($Environment.tenant_id)"
    
    # Override script variables with environment settings
    $script:base_url = $Environment.base_url
    $script:tenantId = $Environment.tenant_id

    # Update server variables to match the new base_url
    $script:server = $script:base_url
    $script:dsg_server = $script:base_url

    # Get tokens directory path
    $tokensDir = Join-Path $PSScriptRoot "helper\tokens"

    # Write environment credentials to files
    if (![string]::IsNullOrWhiteSpace($Environment.launchpad_oauth2_b64)) {
        $basicAuthPath = Join-Path $tokensDir "basic_auth_password.txt"
        Set-Content -Path $basicAuthPath -Value $Environment.launchpad_oauth2_b64 -NoNewline
        Write-Host "  Updated OAuth2 credentials"
    }

    if (![string]::IsNullOrWhiteSpace($Environment.eh_launchpad_username) -and ![string]::IsNullOrWhiteSpace($Environment.eh_launchpad_password_b64)) {
        $formUserPath = Join-Path $tokensDir "form_username.txt"
        $formPassPath = Join-Path $tokensDir "form_password.txt"
        Set-Content -Path $formUserPath -Value $Environment.eh_launchpad_username -NoNewline
        Set-Content -Path $formPassPath -Value $Environment.eh_launchpad_password_b64 -NoNewline
        Write-Host "  Updated Employee Hub credentials"
    }
    
    # Update tenant_id in all helper JSON files
    Update-HelperJsonTenantId -TenantId $script:tenantId -Username $Environment.eh_launchpad_username
    
    Write-Host "[OK] Environment configuration applied"
    Write-Host "===================================`n"
}

# Function to update tenant_id and username in helper JSON files
function Update-HelperJsonTenantId {
    param(
        [string]$TenantId,
        [string]$Username
    )
    
    if ([string]::IsNullOrWhiteSpace($TenantId)) {
        return
    }
    
    $helperDir = Join-Path $PSScriptRoot "helper"
    Write-Host "Updating helper JSON files with tenant_id: $TenantId"
    
    # Update onboarding JSON files
    $onboardingDir = Join-Path $helperDir "onboarding"
    if (Test-Path $onboardingDir) {
        Get-ChildItem -Path $onboardingDir -Filter "*.json" | ForEach-Object {
            try {
                $content = Get-Content $_.FullName -Raw | ConvertFrom-Json
                
                # Update tenant_id fields
                if ($content.PSObject.Properties.Name -contains 'tenant_id') {
                    $content.tenant_id = $TenantId
                }
                if ($content.PSObject.Properties.Name -contains 'tenantId') {
                    $content.tenantId = $TenantId
                }
                if ($content.restrictions -and ($content.restrictions.PSObject.Properties.Name -contains 'tenantId')) {
                    $content.restrictions.tenantId = $TenantId
                }
                
                $content | ConvertTo-Json -Depth 10 | Set-Content $_.FullName
                Write-Host "  Updated $($_.Name)"
            } catch {
                Write-Host "  Warning: Failed to update $($_.Name): $_"
            }
        }
    }
    
    # Update init/get_store.json
    $getStoreJson = Join-Path $helperDir "init\get_store.json"
    if (Test-Path $getStoreJson) {
        try {
            $content = Get-Content $getStoreJson -Raw | ConvertFrom-Json
            if ($content.station) {
                $content.station.tenantId = $TenantId
            }
            $content | ConvertTo-Json -Depth 10 | Set-Content $getStoreJson
            Write-Host "  Updated get_store.json"
        } catch {
            Write-Host "  Warning: Failed to update get_store.json: $_"
        }
    }
    
    # Update init/storehub/update_config.json with username if provided
    if (![string]::IsNullOrWhiteSpace($Username)) {
        $storehubConfig = Join-Path $helperDir "init\storehub\update_config.json"
        if (Test-Path $storehubConfig) {
            try {
                $content = Get-Content $storehubConfig -Raw | ConvertFrom-Json
                if ($content.PSObject.Properties.Name -contains 'user') {
                    $content.user = $Username
                }
                $content | ConvertTo-Json -Depth 10 | Set-Content $storehubConfig
                Write-Host "  Updated storehub/update_config.json"
            } catch {
                Write-Host "  Warning: Failed to update update_config.json: $_"
            }
        }
    }
    
    # Update structure/create_structure.json
    $createStructureJson = Join-Path $helperDir "structure\create_structure.json"
    if (Test-Path $createStructureJson) {
        try {
            # First handle template placeholders
            $content = Get-Content $createStructureJson -Raw
            $content = $content -replace '@TENANT_ID@', $TenantId
            
            # Then handle actual JSON values
            try {
                $jsonContent = $content | ConvertFrom-Json
                if ($jsonContent.parentNode) {
                    $jsonContent.parentNode.tenantId = $TenantId
                }
                if (![string]::IsNullOrWhiteSpace($Username) -and ($jsonContent.PSObject.Properties.Name -contains 'user')) {
                    $jsonContent.user = $Username
                }
                $content = $jsonContent | ConvertTo-Json -Depth 10
            } catch {
                # If JSON parsing fails, just use the template-replaced version
            }
            
            $content | Set-Content $createStructureJson
            Write-Host "  Updated create_structure.json"
        } catch {
            Write-Host "  Warning: Failed to update create_structure.json: $_"
        }
    }
    
    Write-Host "Helper JSON files updated successfully"
}

# Function to extract version from any package filename
function Get-PackageVersion {
    param(
        [string]$PackageFile,
        [string]$ComponentPrefix
    )
    
    # Get filename without extension
    $filename = [System.IO.Path]::GetFileNameWithoutExtension($PackageFile)
    
    # Try different patterns to extract version
    
    # Pattern 1: prefix-1.2.3 (standard format)
    if ($filename -match "^$ComponentPrefix-(\d+(\.\d+)*)$") {
        return $matches[1]
    }
    
    # Pattern 2: prefix-1.2.3-suffix (with additional info)
    if ($filename -match "^$ComponentPrefix-(\d+(\.\d+)*)-") {
        return $matches[1]
    }
    
    # Pattern 3: prefix_1_2_3 (underscore format)
    $pattern3 = '^' + $ComponentPrefix + '[_-](\d+)[_\.](\d+)[_\.](\d+)'
    if ($filename -match $pattern3) {
        return "$($matches[1]).$($matches[2]).$($matches[3])"
    }
    
    # Pattern 4: prefix1.2.3 (no separator)
    if ($filename -match "^$ComponentPrefix(\d+(\.\d+)*)$") {
        return $matches[1]
    }
    
    # Pattern 5: just extract any sequence of numbers and dots
    if ($filename -match '(\d+(\.\d+)*)') {
        return $matches[1]
    }
    
    # If no pattern matches, return the original filename without prefix
    $version = $filename -replace "^$ComponentPrefix-",''
    if ([string]::IsNullOrEmpty($version)) {
        Write-Host "Error: Could not extract version from filename $PackageFile"
        return $null
    }
    return $version
}

# Function to get JRE version from filename
function Get-JreVersion {
    param($JreZip)
    
    # Get filename without extension
    $filename = [System.IO.Path]::GetFileNameWithoutExtension($JreZip)
    
    # Special case for Java_zulujre pattern
    if ($filename -match "Java_zulujre.*?[-_](\d+\.\d+\.\d+)") {
        Write-Host "Detected Java version $($matches[1]) from Zulu JRE filename"
        return $matches[1]
    }
    
    # Special case for x64/x86 in filename to avoid extracting "64" as version
    if ($filename -match "x64-(\d+\.\d+\.\d+)") {
        Write-Host "Detected Java version $($matches[1]) from x64 pattern"
        return $matches[1]
    }
    if ($filename -match "x86-(\d+\.\d+\.\d+)") {
        Write-Host "Detected Java version $($matches[1]) from x86 pattern"
        return $matches[1]
    }
    
    # Try jre prefix first, then java if that fails
    $version = Get-PackageVersion -PackageFile $JreZip -ComponentPrefix "jre"
    if ([string]::IsNullOrEmpty($version)) {
        $version = Get-PackageVersion -PackageFile $JreZip -ComponentPrefix "java"
    }
    
    # Validate version format - if it's just a number like "64", it's probably wrong
    if ($version -match "^\d+$" -and $filename -match "(\d+\.\d+\.\d+)") {
        # Extract version with format like 11.0.18
        Write-Host "Correcting invalid version '$version' to $($matches[1])"
        return $matches[1]
    }
    
    return $version
}

# Function to get Tomcat version from filename
function Get-TomcatVersion {
    param($TomcatZip)
    return Get-PackageVersion -PackageFile $TomcatZip -ComponentPrefix "tomcat"
}

# Function to fetch default versions from Employee Hub Service API
function Get-DefaultVersions {
    param(
        [string]$BaseUrl,
        [string]$TenantId = "001"
    )

    try {
        Write-Host "Fetching default versions from Employee Hub Service API..."

        # Get bearer token from access_token.txt (should be fresh from onboarding)
        $tokenFile = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
        if (-not (Test-Path $tokenFile)) {
            Write-Host "Warning: Bearer token file not found at $tokenFile"
            return $null
        }

        $bearerToken = Get-Content $tokenFile -Raw
        if ([string]::IsNullOrWhiteSpace($bearerToken)) {
            Write-Host "Warning: Bearer token is empty"
            return $null
        }

        $bearerToken = $bearerToken.Trim()

        # Prepare headers (including Referer as in working example)
        $headers = @{
            "authorization" = "Bearer $bearerToken"
            "gk-tenant-id" = $TenantId
            "Referer" = "https://$BaseUrl/employee-hub/app/index.html"
        }

        # Initialize versions tracking with source information
        $versions = @{}
        $versionSources = @{}

        Write-Host "Fetching component versions using FP-first, FPD-fallback strategy..."

        # Step 1: Try FP scope first (modified/customized versions)
        Write-Host "Step 1: Checking FP scope for modified/customized versions..."
        $fpApiUrl = "https://$BaseUrl/employee-hub-service/services/rest/v1/properties?scope=FP`&referenceId=platform"

        try {
            $fpResponse = Invoke-RestMethod -Uri $fpApiUrl -Method Get -Headers $headers -TimeoutSec 30

            # Parse FP scope results - try Update_Version first, then fall back to Version
            foreach ($property in $fpResponse) {
                if ($property.value) {
                    switch ($property.propertyId) {
                        "POSClient_Update_Version" {
                            $versions["POS"] = $property.value
                            $versionSources["POS"] = "FP (Modified)"
                        }
                        "POSClient_Version" {
                            if (-not $versions.ContainsKey("POS")) {
                                $versions["POS"] = $property.value
                                $versionSources["POS"] = "FP (Modified)"
                            }
                        }
                        "OneX_Version" {
                            $versions["ONEX-POS"] = $property.value
                            $versionSources["ONEX-POS"] = "FP (Modified)"
                        }
                        "OneX_Update_Version" {
                            if (-not $versions.ContainsKey("ONEX-POS")) {
                                $versions["ONEX-POS"] = $property.value
                                $versionSources["ONEX-POS"] = "FP (Modified)"
                            }
                        }
                        "WDM_Update_Version" {
                            $versions["WDM"] = $property.value
                            $versionSources["WDM"] = "FP (Modified)"
                        }
                        "WDM_Version" {
                            if (-not $versions.ContainsKey("WDM")) {
                                $versions["WDM"] = $property.value
                                $versionSources["WDM"] = "FP (Modified)"
                            }
                        }
                        "FlowService_Update_Version" {
                            $versions["FLOW-SERVICE"] = $property.value
                            $versionSources["FLOW-SERVICE"] = "FP (Modified)"
                        }
                        "FlowService_Version" {
                            if (-not $versions.ContainsKey("FLOW-SERVICE")) {
                                $versions["FLOW-SERVICE"] = $property.value
                                $versionSources["FLOW-SERVICE"] = "FP (Modified)"
                            }
                        }
                        "LPA_Update_Version" {
                            $versions["LPA-SERVICE"] = $property.value
                            $versionSources["LPA-SERVICE"] = "FP (Modified)"
                        }
                        "LPA_Version" {
                            if (-not $versions.ContainsKey("LPA-SERVICE")) {
                                $versions["LPA-SERVICE"] = $property.value
                                $versionSources["LPA-SERVICE"] = "FP (Modified)"
                            }
                        }
                        "SH_Update_Version" {
                            $versions["STOREHUB-SERVICE"] = $property.value
                            $versionSources["STOREHUB-SERVICE"] = "FP (Modified)"
                        }
                        "StoreHub_Version" {
                            if (-not $versions.ContainsKey("STOREHUB-SERVICE")) {
                                $versions["STOREHUB-SERVICE"] = $property.value
                                $versionSources["STOREHUB-SERVICE"] = "FP (Modified)"
                            }
                        }
                    }
                }
            }

            Write-Host "Found $($versions.Count) components in FP scope"
        } catch {
            Write-Host "Warning: FP scope request failed: $($_.Exception.Message)"
        }

        # Step 2: For components not found in FP, try FPD scope (default versions)
        $allComponents = @("POS", "ONEX-POS", "WDM", "FLOW-SERVICE", "LPA-SERVICE", "STOREHUB-SERVICE", "RCS-SERVICE")
        $missingComponents = $allComponents | Where-Object { -not $versions.ContainsKey($_) }

        if ($missingComponents.Count -gt 0) {
            Write-Host "Step 2: Checking FPD scope for $($missingComponents.Count) missing components..."
            $fpdApiUrl = "https://$BaseUrl/employee-hub-service/services/rest/v1/properties?scope=FPD`&referenceId=platform"

            try {
                $fpdResponse = Invoke-RestMethod -Uri $fpdApiUrl -Method Get -Headers $headers -TimeoutSec 30

                # Parse FPD scope results for missing components only - try Update_Version first, then fall back to Version
                foreach ($property in $fpdResponse) {
                    if ($property.value) {
                        switch ($property.propertyId) {
                            "POSClient_Update_Version" {
                                if (-not $versions.ContainsKey("POS")) {
                                    $versions["POS"] = $property.value
                                    $versionSources["POS"] = "FPD (Default)"
                                }
                            }
                            "POSClient_Version" {
                                if (-not $versions.ContainsKey("POS")) {
                                    $versions["POS"] = $property.value
                                    $versionSources["POS"] = "FPD (Default)"
                                }
                            }
                            "OneX_Version" {
                                if (-not $versions.ContainsKey("ONEX-POS")) {
                                    $versions["ONEX-POS"] = $property.value
                                    $versionSources["ONEX-POS"] = "FPD (Default)"
                                }
                            }
                            "OneX_Update_Version" {
                                if (-not $versions.ContainsKey("ONEX-POS")) {
                                    $versions["ONEX-POS"] = $property.value
                                    $versionSources["ONEX-POS"] = "FPD (Default)"
                                }
                            }
                            "WDM_Update_Version" {
                                if (-not $versions.ContainsKey("WDM")) {
                                    $versions["WDM"] = $property.value
                                    $versionSources["WDM"] = "FPD (Default)"
                                }
                            }
                            "WDM_Version" {
                                if (-not $versions.ContainsKey("WDM")) {
                                    $versions["WDM"] = $property.value
                                    $versionSources["WDM"] = "FPD (Default)"
                                }
                            }
                            "FlowService_Update_Version" {
                                if (-not $versions.ContainsKey("FLOW-SERVICE")) {
                                    $versions["FLOW-SERVICE"] = $property.value
                                    $versionSources["FLOW-SERVICE"] = "FPD (Default)"
                                }
                            }
                            "FlowService_Version" {
                                if (-not $versions.ContainsKey("FLOW-SERVICE")) {
                                    $versions["FLOW-SERVICE"] = $property.value
                                    $versionSources["FLOW-SERVICE"] = "FPD (Default)"
                                }
                            }
                            "LPA_Update_Version" {
                                if (-not $versions.ContainsKey("LPA-SERVICE")) {
                                    $versions["LPA-SERVICE"] = $property.value
                                    $versionSources["LPA-SERVICE"] = "FPD (Default)"
                                }
                            }
                            "LPA_Version" {
                                if (-not $versions.ContainsKey("LPA-SERVICE")) {
                                    $versions["LPA-SERVICE"] = $property.value
                                    $versionSources["LPA-SERVICE"] = "FPD (Default)"
                                }
                            }
                            "SH_Update_Version" {
                                if (-not $versions.ContainsKey("STOREHUB-SERVICE")) {
                                    $versions["STOREHUB-SERVICE"] = $property.value
                                    $versionSources["STOREHUB-SERVICE"] = "FPD (Default)"
                                }
                            }
                            "StoreHub_Version" {
                                if (-not $versions.ContainsKey("STOREHUB-SERVICE")) {
                                    $versions["STOREHUB-SERVICE"] = $property.value
                                    $versionSources["STOREHUB-SERVICE"] = "FPD (Default)"
                                }
                            }
                        }
                    }
                }

                Write-Host "Found additional $($versions.Count - ($allComponents.Count - $missingComponents.Count)) components in FPD scope"
            } catch {
                Write-Host "Warning: FPD scope request failed: $($_.Exception.Message)"
            }
        }

        Write-Host "Successfully fetched component versions:"
        foreach ($key in $versions.Keys) {
            $source = if ($versionSources.ContainsKey($key)) { $versionSources[$key] } else { "Unknown" }
            Write-Host "  $key`: $($versions[$key]) ($source)"
        }

        return $versions

    } catch {
        Write-Host "Warning: Failed to fetch default versions from API: $($_.Exception.Message)"
        Write-Host "Falling back to hardcoded versions..."
        return $null
    }
}

# Function to fetch default versions from Config-Service API
function Get-DefaultVersions-ConfigService {
    param(
        [string]$BaseUrl,
        [string]$TenantId = "001",
        [hashtable]$SystemTypes
    )

    try {
        Write-Host "Fetching default versions from Config-Service API..."

        # Get bearer token from access_token.txt
        $tokenFile = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
        if (-not (Test-Path $tokenFile)) {
            Write-Host "Warning: Bearer token file not found at $tokenFile"
            return $null
        }

        $bearerToken = Get-Content $tokenFile -Raw
        if ([string]::IsNullOrWhiteSpace($bearerToken)) {
            Write-Host "Warning: Bearer token is empty"
            return $null
        }

        $bearerToken = $bearerToken.Trim()

        # Prepare headers
        $headers = @{
            "authorization" = "Bearer $bearerToken"
            "content-type" = "application/json"
        }

        # Initialize versions tracking
        $versions = @{}
        $versionSources = @{}

        # API URL
        $apiUrl = "https://$BaseUrl/api/config/services/rest/infrastructure/v1/versions/search"
        Write-Host "Using Config-Service API: $apiUrl"

        # Fetch versions for each component
        foreach ($component in $SystemTypes.Keys) {
            $systemName = $SystemTypes[$component]
            Write-Host "Fetching versions for $component (systemName: $systemName)..."

            $body = @{ systemName = $systemName } | ConvertTo-Json

            try {
                $response = Invoke-RestMethod -Uri $apiUrl -Method Post -Headers $headers -Body $body -TimeoutSec 30

                if ($response.versionNameList -and $response.versionNameList.Count -gt 0) {
                    # Sort versions and take the highest (latest)
                    $latestVersion = ($response.versionNameList | Sort-Object { [System.Version]($_ -replace '^v','') } -Descending)[0]
                    $versions[$component] = $latestVersion
                    $versionSources[$component] = "Config-Service"
                    Write-Host "  Found $component`: $latestVersion (available: $($response.versionNameList.Count) versions)"
                } else {
                    Write-Host "  No versions found for $component"
                }
            } catch {
                Write-Host "  Warning: Failed to fetch $component`: $($_.Exception.Message)"
            }
        }

        Write-Host "Successfully fetched component versions from Config-Service:"
        foreach ($key in $versions.Keys) {
            $source = if ($versionSources.ContainsKey($key)) { $versionSources[$key] } else { "Unknown" }
            Write-Host "  $key`: $($versions[$key]) ($source)"
        }

        return $versions

    } catch {
        Write-Host "Warning: Failed to fetch default versions from Config-Service API: $($_.Exception.Message)"
        Write-Host "Falling back to hardcoded versions..."
        return $null
    }
}

# ============================================================================
# MULTI-ENVIRONMENT SUPPORT FUNCTIONS
# ============================================================================

# Initialize tenant_id from main configuration (can be overridden by environment)
$tenantId = "@TENANT_ID@"

# Function to load environments from environments.json
function Load-Environments {
    $envFile = Join-Path $PSScriptRoot "helper\environments\environments.json"
    if (Test-Path $envFile) {
        try {
            $raw = Get-Content $envFile -Raw | ConvertFrom-Json
            # Normalize to an object with an 'environments' array regardless of file shape
            if ($null -ne $raw -and ($raw.PSObject.Properties.Name -contains 'environments')) {
                return $raw
            } elseif ($raw -is [System.Collections.IEnumerable]) {
                # Create a PSCustomObject instead of hashtable for consistency
                return [PSCustomObject]@{ environments = @($raw) }
            } else {
                return [PSCustomObject]@{ environments = @() }
            }
        } catch {
            Write-Host "Warning: Failed to load environments.json: $_"
            return [PSCustomObject]@{ environments = @() }
        }
    }
    return [PSCustomObject]@{ environments = @() }
}

# ============================================================================
# SCRIPT CONFIGURATION (may be overridden by environment config above)
# ============================================================================

# Update these lines to use the base_url
$server = $base_url
$dsg_server = $base_url

# Basic configuration
$version = "v1.0.0"
$base_install_dir = "C:\gkretail"

# Set component-specific configurations
$systemType = switch ($ComponentType) {
    'POS' { "CSE-OPOS-CLOUD" }
    'ONEX-POS' { "CSE-OPOS-ONEX-CLOUD" }
    'WDM' { "CSE-wdm" }
    'FLOW-SERVICE' { "CSE-FLOWSERVICE-CLOUD" }
    'LPA-SERVICE' { "CSE-lps-lpa" }
    'STOREHUB-SERVICE' { "CSE-sh-cloud" }
    'RCS-SERVICE' { "@RCS_SYSTEM_TYPE@" }
    default { "CSE-OPOS-CLOUD" }
}

# Set installation directory based on component type
$install_dir = Join-Path $base_install_dir $(
    if ($ComponentType -eq 'POS') { "pos-full" }
    elseif ($ComponentType -eq 'ONEX-POS') { "onex" }
    elseif ($ComponentType -eq 'WDM') { "wdm" }
    elseif ($ComponentType -eq 'FLOW-SERVICE') { "flow-service" }
    elseif ($ComponentType -eq 'LPA-SERVICE') { "lpa-service" }
    elseif ($ComponentType -eq 'STOREHUB-SERVICE') { "storehub-service" }
    elseif ($ComponentType -eq 'RCS-SERVICE') { "rcs" }
    else { "wdm" }
)

# Save the original script default base_url for validation in update mode
$script:defaultBaseUrl = $base_url

# Check if this is an update of an existing installation
$isUpdate = $false
if (Test-Path $install_dir) {
    # Check for log folders
    $logPath = Join-Path $install_dir "log"
    $logsPath = Join-Path $install_dir "logs"

    # Determine which log folder exists
    $logFolderPath = $null
    if (Test-Path $logPath) {
        $logFolderPath = $logPath
    } elseif (Test-Path $logsPath) {
        $logFolderPath = $logsPath
    }

    # If a log folder exists, check for recent activity (last 7 days)
    if ($logFolderPath) {
        Write-Host "Found existing installation at $install_dir with log folder at $logFolderPath"

        try {
            $recentFiles = Get-ChildItem -Path $logFolderPath -Recurse -File |
                           Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }

            if ($recentFiles.Count -gt 0) {
                Write-Host "Found $($recentFiles.Count) recently modified log files (within 7 days)"
                Write-Host "This appears to be an active installation. Performing update instead of full installation."
                $isUpdate = $true
            } else {
                Write-Host "No recent activity found in logs. Performing full installation."
            }
        } catch {
            Write-Host "Error checking log files: $_"
            Write-Host "Continuing with full installation."
        }
    } else {
        Write-Host "No log folder found. Performing full installation."
    }
} else {
    Write-Host "Installation directory does not exist. Performing full installation."
}

# For update mode, extract values from the existing installation FIRST (before environment matching)
if ($isUpdate) {
    Write-Host "Running in update mode - attempting to extract configuration from existing installation"

    # Look for station.properties in the installation directory
    $stationPropertiesPath = Join-Path $install_dir "station.properties"
    if (Test-Path $stationPropertiesPath) {
        Write-Host "Found existing station.properties at: $stationPropertiesPath"
        $stationPropertiesContent = Get-Content -Path $stationPropertiesPath -Raw

        # Extract the store ID
        if ($stationPropertiesContent -match 'station\.storeId=([^\r\n]+)') {
            $storeNumber = $matches[1]
            Write-Host "Found Store ID in station.properties: $storeNumber"
        }

        # Extract the workstation ID
        if ($stationPropertiesContent -match 'station\.workstationId=([^\r\n]+)') {
            $workstationId = $matches[1]
            Write-Host "Found Workstation ID in station.properties: $workstationId"
        }

        # Extract the config service URL (with escaped colons)
        if ($stationPropertiesContent -match 'configService\.url=([^\r\n]+)') {
            $configServiceUrl = $matches[1]
            # Unescape the colons: https\://domain\:443/path -> https://domain:443/path
            $configServiceUrl = $configServiceUrl -replace '\\:', ':'
            Write-Host "Found Config Service URL in station.properties: $configServiceUrl"

            # Extract base URL from config service URL
            # Example: https://dev.cse.cloud4retail.co:443/api/config -> dev.cse.cloud4retail.co
            if ($configServiceUrl -match 'https?://([^:/]+)') {
                $script:extractedBaseUrl = $matches[1]
                Write-Host "Extracted base URL: $script:extractedBaseUrl"
            } else {
                Write-Host "Warning: Could not parse base URL from config service URL" -ForegroundColor Yellow
            }
        } else {
            Write-Host "Warning: No configService.url found in station.properties" -ForegroundColor Yellow
        }

        # Extract the tenant ID
        if ($stationPropertiesContent -match 'station\.tenantId=([^\r\n]+)') {
            $script:extractedTenantId = $matches[1]
            Write-Host "Found Tenant ID in station.properties: $script:extractedTenantId"
        } else {
            Write-Host "Warning: No station.tenantId found in station.properties" -ForegroundColor Yellow
        }

        # If both store ID and workstation ID were found, mark detection as complete
        if (![string]::IsNullOrEmpty($storeNumber) -and ![string]::IsNullOrEmpty($workstationId)) {
            $hostnameDetected = $true
            Write-Host "Using Store ID and Workstation ID from existing installation"
        } else {
            Write-Host "Error: Could not extract complete information from station.properties" -ForegroundColor Red
            Write-Host "Update not possible. Exiting." -ForegroundColor Red
            exit 1
        }
    } else {
        Write-Host "Error: No station.properties found at: $stationPropertiesPath" -ForegroundColor Red
        Write-Host "Update not possible. Exiting." -ForegroundColor Red
        exit 1
    }
}

# Multi-environment selection (skip in update mode)
if (-not $isUpdate) {
    # Load environments configuration
    $environments = Load-Environments
    if ($null -eq $environments) {
        Write-Host "Warning: No environments.json found, using script defaults"
        # Restore default credentials if backups exist (check each file individually)
        $tokensDir = Join-Path $PSScriptRoot "helper\tokens"
        $restored = $false
        if (Test-Path (Join-Path $tokensDir "basic_auth_password.txt.default")) {
            Copy-Item (Join-Path $tokensDir "basic_auth_password.txt.default") (Join-Path $tokensDir "basic_auth_password.txt") -Force
            $restored = $true
        }
        if (Test-Path (Join-Path $tokensDir "form_password.txt.default")) {
            Copy-Item (Join-Path $tokensDir "form_password.txt.default") (Join-Path $tokensDir "form_password.txt") -Force
            $restored = $true
        }
        if (Test-Path (Join-Path $tokensDir "form_username.txt.default")) {
            Copy-Item (Join-Path $tokensDir "form_username.txt.default") (Join-Path $tokensDir "form_username.txt") -Force
            $restored = $true
        }
        if ($restored) {
            Write-Host "Restored default credentials"
        }
    } else {
        # Select environment based on CLI parameter, file, or interactive prompt
        $selectedEnv = Select-Environment -EnvAlias $Env -EnvName $EnvironmentName

        if ($null -ne $selectedEnv) {
            # Apply the selected environment configuration (overrides base_url, credentials, tenant_id)
            Apply-EnvironmentConfig -Environment $selectedEnv -BaseUrlVar ([ref]$base_url)
            Write-Host "Environment '$($selectedEnv.alias)' applied successfully"
        } else {
            Write-Host "No environment selected, using script defaults"
            # Restore default credentials if backups exist (check each file individually)
            $tokensDir = Join-Path $PSScriptRoot "helper\tokens"
            $restored = $false
            if (Test-Path (Join-Path $tokensDir "basic_auth_password.txt.default")) {
                Copy-Item (Join-Path $tokensDir "basic_auth_password.txt.default") (Join-Path $tokensDir "basic_auth_password.txt") -Force
                $restored = $true
            }
            if (Test-Path (Join-Path $tokensDir "form_password.txt.default")) {
                Copy-Item (Join-Path $tokensDir "form_password.txt.default") (Join-Path $tokensDir "form_password.txt") -Force
                $restored = $true
            }
            if (Test-Path (Join-Path $tokensDir "form_username.txt.default")) {
                Copy-Item (Join-Path $tokensDir "form_username.txt.default") (Join-Path $tokensDir "form_username.txt") -Force
                $restored = $true
            }
            if ($restored) {
                Write-Host "Restored default credentials"
            }
        }
    }
} else {
    Write-Host "Update mode detected - attempting to match environment from existing configuration"

    # Load environments configuration
    $environments = Load-Environments

    if ($null -eq $environments -or $environments.environments.Count -eq 0) {
        Write-Host "No multi-environment configuration found, using extracted values from existing installation" -ForegroundColor Cyan

        # Use values extracted from station.properties with script defaults
        if (![string]::IsNullOrEmpty($script:extractedBaseUrl)) {
            # Validate that extracted base URL matches script default
            if ($script:extractedBaseUrl -ne $script:defaultBaseUrl) {
                Write-Host "Warning: Extracted base URL does not match script default" -ForegroundColor Red
                Write-Host "  Extracted from station.properties: $script:extractedBaseUrl" -ForegroundColor Red
                Write-Host "  Script default: $script:defaultBaseUrl" -ForegroundColor Red
                Write-Host "`nYou can either:" -ForegroundColor Yellow
                Write-Host "  1. Use an installation script generated for '$script:extractedBaseUrl', OR" -ForegroundColor Yellow
                Write-Host "  2. Configure environments in environments.json with matching base_url, OR" -ForegroundColor Yellow
                Write-Host "  3. Run in fresh install mode (delete existing installation), OR" -ForegroundColor Yellow
                Write-Host "  4. Proceed anyway (use only for GK QA environments)" -ForegroundColor Yellow
                Write-Host ""
                Write-Host "WARNING: Proceeding with mismatched URLs should only be used in GK QA environments" -ForegroundColor Yellow
                Write-Host "         where base URLs may differ (e.g., qa-gkr.cloud4retail.co vs qa.cloud4retail.co)" -ForegroundColor Yellow
                Write-Host ""
                $response = Read-Host "Do you want to proceed anyway? (y/N)"
                if ($response -eq 'y' -or $response -eq 'Y') {
                    Write-Host "Proceeding with mismatched base URL..." -ForegroundColor Yellow
                } else {
                    Write-Host "Update cancelled." -ForegroundColor Red
                    exit 1
                }
            }
            $base_url = $script:extractedBaseUrl
            Write-Host "Using base URL from station.properties: $base_url"
        } else {
            Write-Host "Using script default base URL: $base_url"
        }

        if (![string]::IsNullOrEmpty($script:extractedTenantId)) {
            $tenantId = $script:extractedTenantId
            $script:tenantId = $script:extractedTenantId
            Write-Host "Using tenant ID from station.properties: $tenantId"
        } else {
            Write-Host "Using script default tenant ID: $tenantId"
        }

        Write-Host "Proceeding with update using script default credentials" -ForegroundColor Green
    } elseif ($environments.environments.Count -gt 0) {
        # Try to match extracted base URL to configured environments
        if (![string]::IsNullOrEmpty($script:extractedBaseUrl)) {
            Write-Host "Attempting to match base URL '$script:extractedBaseUrl' to configured environments..."

            $matchedEnv = $environments.environments | Where-Object {
                $_.base_url -eq $script:extractedBaseUrl
            } | Select-Object -First 1

            if ($null -ne $matchedEnv) {
                Write-Host "Successfully matched environment: $($matchedEnv.name) ($($matchedEnv.alias))" -ForegroundColor Green
                # Apply the matched environment configuration
                Apply-EnvironmentConfig -Environment $matchedEnv -BaseUrlVar ([ref]$base_url)
                Write-Host "Environment configuration applied successfully"
            } else {
                Write-Host "Error: No matching environment found for base URL: $script:extractedBaseUrl" -ForegroundColor Red
                Write-Host "Available environments:" -ForegroundColor Yellow
                foreach ($envItem in $environments.environments) {
                    Write-Host "  - $($envItem.name) ($($envItem.alias)): $($envItem.base_url)" -ForegroundColor Yellow
                }
                Write-Host "`nPlease either:" -ForegroundColor Red
                Write-Host "  1. Add an environment with base_url='$script:extractedBaseUrl' to environments.json, OR" -ForegroundColor Red
                Write-Host "  2. Update the existing installation to use a configured environment, OR" -ForegroundColor Red
                Write-Host "  3. Run in fresh install mode (delete existing installation)" -ForegroundColor Red
                exit 1
            }
        } else {
            Write-Host "Warning: Could not extract base URL from station.properties" -ForegroundColor Yellow
            Write-Host "Falling back to manual environment selection" -ForegroundColor Yellow

            $selectedEnv = Select-Environment -EnvAlias $Env -EnvName $EnvironmentName

            if ($null -ne $selectedEnv) {
                Apply-EnvironmentConfig -Environment $selectedEnv -BaseUrlVar ([ref]$base_url)
                Write-Host "Environment '$($selectedEnv.alias)' applied successfully"
            } else {
                Write-Host "Error: No environment selected. Update cannot proceed." -ForegroundColor Red
                exit 1
            }
        }
    }

    # Override tenant ID with value from station.properties if available
    if (![string]::IsNullOrEmpty($script:extractedTenantId)) {
        Write-Host "Overriding tenant ID with value from station.properties: $script:extractedTenantId"
        $script:tenantId = $script:extractedTenantId
        # Also update the main $tenantId variable used throughout the script
        $tenantId = $script:extractedTenantId
    }
}

# Determine component version based on UseDefaultVersions flag
if ($UseDefaultVersions) {
    Write-Host "UseDefaultVersions flag is enabled - fetching versions from Employee Hub Service API..."

    # Use tenant ID from environment config if available, otherwise use main config default
    if ($script:tenantId) {
        $tenantId = $script:tenantId  # Use environment-specific tenant ID
    }
    # Otherwise $tenantId already has the value from main configuration (@TENANT_ID@)

    # First, ensure we have a fresh OAuth token (just the token, not full onboarding)
    Write-Host "Getting fresh OAuth token for version API call..."
    try {
        # Get token using the same logic as onboarding.ps1 but without CIMS call
        $tokensPath = Join-Path $PSScriptRoot "helper\tokens"
        $basicAuthPath = Join-Path $tokensPath "basic_auth_password.txt"
        $formPasswordPath = Join-Path $tokensPath "form_password.txt"

        Write-Host "[DEBUG] Tokens path: $tokensPath"
        Write-Host "[DEBUG] Basic auth file exists: $(Test-Path $basicAuthPath)"
        Write-Host "[DEBUG] Form password file exists: $(Test-Path $formPasswordPath)"

        if ((Test-Path $basicAuthPath) -and (Test-Path $formPasswordPath)) {
            $username = "launchpad"
            # Read credentials (Base64 encoded) and decode them
            $basicAuthPasswordEncoded = (Get-Content $basicAuthPath -Raw).Trim()
            $formPasswordEncoded = (Get-Content $formPasswordPath -Raw).Trim()
            
            # Decode from Base64
            $basicAuthPassword = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($basicAuthPasswordEncoded))
            $formPassword = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($formPasswordEncoded))
            
            # Read username from file (written by environment application), fallback to template default
            $formUsernamePath = Join-Path $tokensPath "form_username.txt"
            if (Test-Path $formUsernamePath) {
                $formUsername = (Get-Content $formUsernamePath -Raw).Trim()
                Write-Host "[DEBUG] Form username from file: $formUsername"
            } else {
                $formUsername = "@FORM_USERNAME@"
                Write-Host "[DEBUG] Form username from template: $formUsername"
            }

            Write-Host "[DEBUG] Form username: $formUsername"
            Write-Host "[DEBUG] Base URL: $base_url"
            Write-Host "[DEBUG] Tenant ID: $tenantId"

            # Create Basic Auth header (same as onboarding.ps1)
            $base64Auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("${username}:${basicAuthPassword}"))

            # Form data (same as onboarding.ps1)
            $body = @{
                username = $formUsername
                password = $formPassword
                grant_type = "password"
            }

            # URL encode form data (same as onboarding.ps1)
            $formData = ($body.GetEnumerator() | ForEach-Object {
                "$([System.Net.WebUtility]::UrlEncode($_.Key))=$([System.Net.WebUtility]::UrlEncode($_.Value))"
            }) -join '&'

            # Get OAuth token (same URL as onboarding.ps1)
            $tokenUrl = "https://$base_url/auth-service/tenants/${tenantId}/oauth/token"
            Write-Host "[DEBUG] Token URL: $tokenUrl"
            # Mask password in debug output
            $maskedFormData = $formData -replace '(password=)[^&]+', '$1********'
            Write-Host "[DEBUG] Request body (URL-encoded): $maskedFormData"
            
            $response = Invoke-RestMethod -Uri $tokenUrl -Method Post -Headers @{Authorization = "Basic $base64Auth"} -Body $formData -ContentType "application/x-www-form-urlencoded"

            # Save the access token (same as onboarding.ps1)
            $accessToken = $response.access_token
            Set-Content -Path (Join-Path $tokensPath "access_token.txt") -Value $accessToken -NoNewline
            Write-Host "OAuth token obtained and saved successfully"
            Write-Host "[DEBUG] Token length: $($accessToken.Length)"
        } else {
            Write-Host "Warning: Required credential files not found, proceeding with existing token..."
        }
    } catch {
        Write-Host "Warning: Failed to get fresh OAuth token: $($_.Exception.Message)"
        if ($_.Exception.Response) {
            try {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $responseBody = $reader.ReadToEnd()
                Write-Host "[DEBUG] Response body: $responseBody"
            } catch {
                Write-Host "[DEBUG] Could not read response body"
            }
        }
        Write-Host "Proceeding with existing token..."
    }

    # Fetch default versions from API based on VersionSource
    Write-Host "Using VersionSource: $VersionSource"
    
    if ($VersionSource -eq "CONFIG") {
        # Use Config-Service API - fetch only the relevant component
        Write-Host "Fetching versions from Config-Service..."

        # Determine system name for the current component
        $allSystemTypes = @{
            "POS" = "@POS_SYSTEM_TYPE@"
            "ONEX-POS" = "@ONEX_POS_SYSTEM_TYPE@"
            "WDM" = "@WDM_SYSTEM_TYPE@"
            "FLOW-SERVICE" = "@FLOW_SERVICE_SYSTEM_TYPE@"
            "LPA-SERVICE" = "@LPA_SERVICE_SYSTEM_TYPE@"
            "STOREHUB-SERVICE" = "@STOREHUB_SERVICE_SYSTEM_TYPE@"
            "RCS-SERVICE" = "@RCS_SYSTEM_TYPE@"
        }

        if ($allSystemTypes.ContainsKey($ComponentType)) {
            $systemTypes = @{ $ComponentType = $allSystemTypes[$ComponentType] }
        } else {
            $systemTypes = @{}
            Write-Host "Warning: Unknown component type '$ComponentType' for Config-Service lookup"
        }

        $defaultVersions = Get-DefaultVersions-ConfigService -BaseUrl $base_url -TenantId $tenantId -SystemTypes $systemTypes
    } else {
        # Use Function Pack (FP/FPD) API (default)
        Write-Host "Fetching versions from Function Pack (FP/FPD)..."
        $defaultVersions = Get-DefaultVersions -BaseUrl $base_url -TenantId $tenantId
    }

    if ($defaultVersions -and $defaultVersions.ContainsKey($ComponentType)) {
        $component_version = $defaultVersions[$ComponentType]
        Write-Host "Using API version for $ComponentType`: $component_version"
    } else {
        Write-Host "Warning: Could not get version for $ComponentType from API, falling back to hardcoded version"
        # Fall back to hardcoded versions
        $component_version = switch ($systemType) {
            "CSE-OPOS-CLOUD" { "@POS_VERSION@" }
            "CSE-OPOS-ONEX-CLOUD" { "@ONEX_POS_VERSION@" }
            "CSE-wdm" { "@WDM_VERSION@" }
            "CSE-FLOWSERVICE-CLOUD" { "@FLOW_SERVICE_VERSION@" }
            "CSE-lps-lpa" { "@LPA_SERVICE_VERSION@" }
            "CSE-sh-cloud" { "@STOREHUB_SERVICE_VERSION@" }
            "@RCS_SYSTEM_TYPE@" { "@RCS_VERSION@" }
            default { "" }
        }
    }
} else {
    Write-Host "Using hardcoded versions from configuration..."
    # Set component-specific version if available
    $component_version = switch ($systemType) {
        "CSE-OPOS-CLOUD" { "@POS_VERSION@" }
        "CSE-OPOS-ONEX-CLOUD" { "@ONEX_POS_VERSION@" }
        "CSE-wdm" { "@WDM_VERSION@" }
        "CSE-FLOWSERVICE-CLOUD" { "@FLOW_SERVICE_VERSION@" }
        "CSE-lps-lpa" { "@LPA_SERVICE_VERSION@" }
        "CSE-sh-cloud" { "@STOREHUB_SERVICE_VERSION@" }
        "@RCS_SYSTEM_TYPE@" { "@RCS_VERSION@" }
        default { "" }
    }
}

# If component version is still empty, use default version
if ([string]::IsNullOrEmpty($component_version)) {
    $component_version = $version
    Write-Host "No specific version found, using default version: $component_version"
} else {
    Write-Host "Using component version: $component_version"
}

# Initialize offline variables
$jre_version = ""
$jre_file = ""
$tomcat_version = ""
$tomcat_file = ""

# Set WDM SSL settings based on base install directory
$security_dir = Join-Path $base_install_dir "security"
# We'll find the actual certificate file dynamically later
$ssl_password = "changeit"

# For StoreHub, set the Firebird server path
$firebird_server_path = "@FIREBIRD_SERVER_PATH@"
# If the placeholder wasn't replaced (still contains @), use a default value
if ($firebird_server_path -like "*@*") {
    $firebird_server_path = "C:\Program Files\Firebird\Firebird_3_0"
    Write-Host "Using default Firebird server path: $firebird_server_path"
}

# For StoreHub, set the Jaybird driver path
$firebird_driver_path_local = "@FIREBIRD_DRIVER_PATH_LOCAL@"
# If the placeholder wasn't replaced (still contains @), use a default value
if ($firebird_driver_path_local -like "*@*") {
    $firebird_driver_path_local = ""
    Write-Host "No default Jaybird driver path set - will detect during installation if available"
}

# Check offline mode
$offline_mode = $offline.IsPresent

# Validate WDM-specific parameters
if ($ComponentType -eq 'WDM') {
    if ([string]::IsNullOrEmpty($ssl_password)) {
        Write-Host "Error: ssl_password is required for WDM installation"
        Stop-TranscriptSafely
        exit 1
    }
}

# Add component-specific package directory check
$package_dir = if ($ComponentType -eq 'LPA-SERVICE') { "offline_package_LPA" }
               elseif ($ComponentType -eq 'STOREHUB-SERVICE') { "offline_package_SH" }
               elseif ($ComponentType -eq 'RCS-SERVICE') { "offline_package_RCS" }
               else { "offline_package_$ComponentType" }

# Update offline mode checks
if ($offline.IsPresent) {
    # Check for component-specific offline package
    if (-not (Test-Path $package_dir)) {
        Write-Host "Error: Offline package directory not found: $package_dir"
        Stop-TranscriptSafely
        exit 1
    }

    # Check for required files based on component type
    if ($ComponentType -eq 'WDM') {
        # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
        $jre_files = @(Get-ChildItem -Path "Java\*.zip" -ErrorAction SilentlyContinue)
        
        # If no jre files found, try more generic patterns
        if ($jre_files.Count -eq 0) {
            $jre_files = @(Get-ChildItem -Path "Java\*jre*.zip" -ErrorAction SilentlyContinue)
            if ($jre_files.Count -eq 0) {
                $jre_files = @(Get-ChildItem -Path "Java\*java*.zip" -ErrorAction SilentlyContinue)
            }
        }
        
        $tomcat_files = @(Get-ChildItem -Path "Tomcat\*.zip" -ErrorAction SilentlyContinue)
        
        # If no tomcat files found, try a more generic pattern
        if ($tomcat_files.Count -eq 0) {
            $tomcat_files = @(Get-ChildItem -Path "Tomcat\*tomcat*.zip" -ErrorAction SilentlyContinue)
        }
        
        # Look for any JAR file to use as installer in the component directory
        $jar_files = @(Get-ChildItem -Path (Join-Path $package_dir "*.jar") -ErrorAction SilentlyContinue)
        $installer_jar = $null
        $has_installer_jar = $false
        
        if ($jar_files.Count -gt 0) {
            if ($jar_files.Count -gt 1) {
                Write-Host "Warning: Multiple JAR files found in $package_dir. Using the first one: $($jar_files[0].Name)"
            }
            $installer_jar = $jar_files[0].FullName
            $has_installer_jar = $true
            Write-Host "Found installer JAR: $($jar_files[0].Name)"
        }
        
        if ($jre_files.Count -eq 0) {
            Write-Host "Error: No JRE/Java package found in Java directory"
            Stop-TranscriptSafely
            exit 1
        }
        
        if ($tomcat_files.Count -eq 0) {
            Write-Host "Error: No Tomcat package found in Tomcat directory"
            Stop-TranscriptSafely
            exit 1
        }
        
        # Use the first matching file if multiple are found
        $jre_file = $jre_files[0].FullName
        $tomcat_file = $tomcat_files[0].FullName
        
        # Extract versions
        $jre_version = Get-JreVersion -JreZip $jre_files[0].Name
        $tomcat_version = Get-TomcatVersion -TomcatZip $tomcat_files[0].Name
        
        Write-Host "Found JRE/Java package: $($jre_files[0].Name), version: $jre_version"
        Write-Host "Found Tomcat package: $($tomcat_files[0].Name), version: $tomcat_version"
        
        $required_files = @(
            (Join-Path $package_dir "Launcher.exe"),
            $jre_file,
            $tomcat_file
        )
        
        # Add installer.jar to required files if it exists
        if ($has_installer_jar) {
            $required_files += $installer_jar
        }
    } elseif ($ComponentType -eq 'STOREHUB-SERVICE') {
        # For StoreHub components - with Jaybird support
        # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
        $jre_files = @(Get-ChildItem -Path "Java\*.zip" -ErrorAction SilentlyContinue)
        
        # If no jre files found, try more generic patterns
        if ($jre_files.Count -eq 0) {
            $jre_files = @(Get-ChildItem -Path "Java\*jre*.zip" -ErrorAction SilentlyContinue)
            if ($jre_files.Count -eq 0) {
                $jre_files = @(Get-ChildItem -Path "Java\*java*.zip" -ErrorAction SilentlyContinue)
            }
        }
        
        $tomcat_files = @(Get-ChildItem -Path "Tomcat\*.zip" -ErrorAction SilentlyContinue)
        
        # If no tomcat files found, try a more generic pattern
        if ($tomcat_files.Count -eq 0) {
            $tomcat_files = @(Get-ChildItem -Path "Tomcat\*tomcat*.zip" -ErrorAction SilentlyContinue)
        }
        
        # Look for Jaybird JAR files
        $jaybird_files = @(Get-ChildItem -Path "Jaybird\*.jar" -ErrorAction SilentlyContinue)
        $jaybird_file = $null
        $has_jaybird = $false
        
        if ($jaybird_files.Count -gt 0) {
            if ($jaybird_files.Count -gt 1) {
                Write-Host "Warning: Multiple Jaybird JAR files found. Using the first one: $($jaybird_files[0].Name)"
            }
            $jaybird_file = $jaybird_files[0].FullName
            $has_jaybird = $true
            Write-Host "Found Jaybird driver: $($jaybird_files[0].Name)"
            
            # Update the firebird_driver_path_local to point to the actual JAR file, not just the directory
            $firebird_driver_path_local = $jaybird_file
            Write-Host "Updated Jaybird driver path to: $firebird_driver_path_local"
        } else {
            Write-Host "Warning: No Jaybird driver found in Jaybird directory"
        }
        
        # Look for any JAR file to use as installer in the component directory
        $jar_files = @(Get-ChildItem -Path (Join-Path $package_dir "*.jar") -ErrorAction SilentlyContinue)
        $installer_jar = $null
        $has_installer_jar = $false
        
        if ($jar_files.Count -gt 0) {
            if ($jar_files.Count -gt 1) {
                Write-Host "Warning: Multiple JAR files found in $package_dir. Using the first one: $($jar_files[0].Name)"
            }
            $installer_jar = $jar_files[0].FullName
            $has_installer_jar = $true
            Write-Host "Found installer JAR: $($jar_files[0].Name)"
        }
        
        # Initialize required files with Launcher.exe
        $required_files = @(
            (Join-Path $package_dir "Launcher.exe")
        )
        
        # Process JRE files if available
        if ($jre_files.Count -gt 0) {
            $jre_file = $jre_files[0].FullName
            $jre_version = Get-JreVersion -JreZip $jre_files[0].Name
            Write-Host "Found JRE/Java package: $($jre_files[0].Name), version: $jre_version"
            $required_files += $jre_file
        } else {
            Write-Host "Error: No JRE/Java package found for $ComponentType"
            Stop-TranscriptSafely
            exit 1
        }
        
        # Process Tomcat files if available
        if ($tomcat_files.Count -gt 0) {
            $tomcat_file = $tomcat_files[0].FullName
            $tomcat_version = Get-TomcatVersion -TomcatZip $tomcat_files[0].Name
            Write-Host "Found Tomcat package: $($tomcat_files[0].Name), version: $tomcat_version"
            $required_files += $tomcat_file
        } else {
            Write-Host "Error: No Tomcat package found for $ComponentType"
            Stop-TranscriptSafely
            exit 1
        }
        
        # Add Jaybird file to required files if it exists
        if ($has_jaybird) {
            $required_files += $jaybird_file
        }
        
        # Add installer.jar to required files if it exists
        if ($has_installer_jar) {
            $required_files += $installer_jar
        }
    } else {
        # For other components - generic approach with improved detection
        # Find JRE and Tomcat packages from dedicated Java and Tomcat directories
        $jre_files = @(Get-ChildItem -Path "Java\*.zip" -ErrorAction SilentlyContinue)
        
        # If no jre files found, try more generic patterns
        if ($jre_files.Count -eq 0) {
            $jre_files = @(Get-ChildItem -Path "Java\*jre*.zip" -ErrorAction SilentlyContinue)
            if ($jre_files.Count -eq 0) {
                $jre_files = @(Get-ChildItem -Path "Java\*java*.zip" -ErrorAction SilentlyContinue)
            }
        }
        
        $tomcat_files = @(Get-ChildItem -Path "Tomcat\*.zip" -ErrorAction SilentlyContinue)
        
        # If no tomcat files found, try a more generic pattern
        if ($tomcat_files.Count -eq 0) {
            $tomcat_files = @(Get-ChildItem -Path "Tomcat\*tomcat*.zip" -ErrorAction SilentlyContinue)
        }
        
        # Look for any JAR file to use as installer in the component directory
        $jar_files = @(Get-ChildItem -Path (Join-Path $package_dir "*.jar") -ErrorAction SilentlyContinue)
        $installer_jar = $null
        $has_installer_jar = $false
        
        if ($jar_files.Count -gt 0) {
            if ($jar_files.Count -gt 1) {
                Write-Host "Warning: Multiple JAR files found in $package_dir. Using the first one: $($jar_files[0].Name)"
            }
            $installer_jar = $jar_files[0].FullName
            $has_installer_jar = $true
            Write-Host "Found installer JAR: $($jar_files[0].Name)"
        }

        # Look for OneX UI package zip in the component directory
        $ui_package_files = @(Get-ChildItem -Path (Join-Path $package_dir "onex-ui-*.zip") -ErrorAction SilentlyContinue)
        $ui_package = $null
        $has_ui_package = $false

        if ($ui_package_files.Count -gt 0) {
            $ui_package = $ui_package_files[0].FullName
            $has_ui_package = $true
            Write-Host "Found OneX UI package: $($ui_package_files[0].Name)"
        }

        # Initialize required files with Launcher.exe
        $required_files = @(
            (Join-Path $package_dir "Launcher.exe")
        )

        # Process JRE files if available
        if ($jre_files.Count -gt 0) {
            $jre_file = $jre_files[0].FullName
            $jre_version = Get-JreVersion -JreZip $jre_files[0].Name
            Write-Host "Found JRE/Java package: $($jre_files[0].Name), version: $jre_version"
            $required_files += $jre_file
        } else {
            Write-Host "No JRE/Java package found for $ComponentType."
        }

        # Process Tomcat files if available
        if ($tomcat_files.Count -gt 0) {
            $tomcat_file = $tomcat_files[0].FullName
            $tomcat_version = Get-TomcatVersion -TomcatZip $tomcat_files[0].Name
            Write-Host "Found Tomcat package: $($tomcat_files[0].Name), version: $tomcat_version"
            $required_files += $tomcat_file
        } else {
            Write-Host "No Tomcat package found for $ComponentType."
        }

        # Add installer.jar to required files if it exists
        if ($has_installer_jar) {
            $required_files += $installer_jar
        }

        # Add UI package to required files if it exists
        if ($has_ui_package) {
            $required_files += $ui_package
        }
    }

    foreach ($file in $required_files) {
        if (-not (Test-Path $file)) {
            Write-Host "Error: Required file not found: $file"
            exit 1
        }
    }

    # Update file paths to use component-specific directory
    $launcher_path = Join-Path $package_dir "Launcher.exe"
    # JRE and Tomcat files are already set in the dynamic detection code above
}

# Create installation directory if it doesn't exist
if (-not (Test-Path $install_dir)) {
    New-Item -ItemType Directory -Path $install_dir -Force
}

# If this is an update in offline mode and we have an installer jar, copy it to the temp directory
if ($isUpdate -and $offline_mode -and $has_installer_jar) {
    $installerTempDir = Join-Path $install_dir "installer\temp"
    
    # Create the temp directory if it doesn't exist
    if (-not (Test-Path $installerTempDir)) {
        Write-Host "Creating installer temp directory: $installerTempDir"
        New-Item -ItemType Directory -Path $installerTempDir -Force | Out-Null
    }
    
    # Copy the installer jar to the temp directory
    $installerJarDest = Join-Path $installerTempDir "installer.jar"
    Write-Host "Copying installer JAR for offline update: $installer_jar -> $installerJarDest"
    try {
        Copy-Item -Path $installer_jar -Destination $installerJarDest -Force
        Write-Host "Successfully copied installer JAR for offline update"
    } catch {
        Write-Host "Warning: Failed to copy installer JAR for offline update: $_"
    }
}

# If this is an update in offline mode and we have a UI package, copy it to the temp directory
if ($isUpdate -and $offline_mode -and $has_ui_package) {
    $installerTempDir = Join-Path $install_dir "installer\temp"

    # Create the temp directory if it doesn't exist
    if (-not (Test-Path $installerTempDir)) {
        Write-Host "Creating installer temp directory: $installerTempDir"
        New-Item -ItemType Directory -Path $installerTempDir -Force | Out-Null
    }

    # Copy the UI package to the temp directory
    $uiPackageName = [System.IO.Path]::GetFileName($ui_package)
    $uiPackageDest = Join-Path $installerTempDir $uiPackageName
    Write-Host "Copying OneX UI package for offline update: $ui_package -> $uiPackageDest"
    try {
        Copy-Item -Path $ui_package -Destination $uiPackageDest -Force
        Write-Host "Successfully copied OneX UI package for offline update"
    } catch {
        Write-Host "Warning: Failed to copy OneX UI package for offline update: $_"
    }
}

# Get hostname
$hs = $env:COMPUTERNAME
if ([string]::IsNullOrEmpty($hs)) {
    Write-Host "Warning: Could not read hostname. Falling back to manual input."
} else {
    Write-Host "-------------------"
    Write-Host "Hostname  : $hs"
    Write-Host "==================="
}

# Initialize variables for Store Number and Workstation ID
$storeNumber = if (![string]::IsNullOrEmpty($storeId)) { $storeId } else { "" }
$workstationId = if (![string]::IsNullOrEmpty($WorkstationId)) { $WorkstationId } else { "" }

# Preserve CLI values - these have highest priority (Priority 0)
$cliStoreId = $storeId
$cliWorkstationId = $WorkstationId

# Priority 0: Check if values provided via CLI parameters
if (![string]::IsNullOrEmpty($cliStoreId)) {
    $storeNumber = $cliStoreId
    Write-Host "Using Store ID from CLI parameter: $storeNumber"
}

if (![string]::IsNullOrEmpty($cliWorkstationId)) {
    $workstationId = $cliWorkstationId
    Write-Host "Using Workstation ID from CLI parameter: $workstationId"
}

# Try to extract Store Number and Workstation ID from hostname
# Only detect values that were NOT provided via CLI
$hostnameDetected = $false

# If both values already provided via CLI, skip all detection
if (![string]::IsNullOrEmpty($storeNumber) -and ![string]::IsNullOrEmpty($workstationId)) {
    $hostnameDetected = $true
    Write-Host "Both Store ID and Workstation ID provided via CLI - skipping detection"
}

# For new installations (not update mode), detect from hostname or prompt user
# Only run detection if we still need values
if (-not $isUpdate) {

    if (-not $hostnameDetected -and -not [string]::IsNullOrEmpty($hs)) {
        # Try different patterns:
        # 1. XXXX-YYY format (e.g., R005-101, 1674-101)
        # 2. SOMENAME-XXXX-YYY format (e.g., SOMENAME-1674-101)

        # HOSTNAME_STORE_WORKSTATION_DETECTION_PLACEHOLDER
    }

    # If hostname detection failed, try file detection
    if (-not $hostnameDetected) {
        if (-not [string]::IsNullOrEmpty($hs)) {
            Write-Host "Could not extract valid Store Number and Workstation ID from hostname."
            Write-Host "Trying file detection..."
        }
        
        # File detection code will be inserted here by the generator
    }

    # If both hostname and file detection failed, prompt for manual input
    # Only prompt for values that are still missing
    if (-not $hostnameDetected) {
        Write-Host "Falling back to manual input for missing values."
        
        # Only prompt for Store Number if not provided
        if ([string]::IsNullOrEmpty($storeNumber)) {
            Write-Host "Please enter the Store Number in one of these formats `(or any custom format`):"
            Write-Host "  - 4 digits `(e.g., 1234`)"
            Write-Host "  - 1 letter + 3 digits `(e.g., R005`)"
            Write-Host "  - 2 letters + 2 digits `(e.g., CA45`)"
            Write-Host "  - Custom format `(e.g., STORE-105`)"
            $storeNumber = Read-Host "Store Number"

            # Validate that something was entered
            if ([string]::IsNullOrWhiteSpace($storeNumber)) {
                Write-Host "Store Number cannot be empty. Please try again."
                $storeNumber = Read-Host "Store Number"
            }
        } else {
            Write-Host "Store Number already provided: $storeNumber"
        }
        
        # Only prompt for Workstation ID if not provided
        if ([string]::IsNullOrEmpty($workstationId)) {
            do {
                $workstationId = Read-Host "Please enter the Workstation ID (numeric)"
            } while ($workstationId -notmatch '^\d+$')
        } else {
            Write-Host "Workstation ID already provided: $workstationId"
        }
    }
}

# Priority 0: CLI values always override detected values
if (![string]::IsNullOrEmpty($cliStoreId)) {
    if ($storeNumber -ne $cliStoreId) {
        Write-Host "CLI Override: Using Store ID '$cliStoreId' (detected: '$storeNumber')"
    }
    $storeNumber = $cliStoreId
}
if (![string]::IsNullOrEmpty($cliWorkstationId)) {
    if ($workstationId -ne $cliWorkstationId) {
        Write-Host "CLI Override: Using Workstation ID '$cliWorkstationId' (detected: '$workstationId')"
    }
    $workstationId = $cliWorkstationId
}

# Print final results
Write-Host "-------------------"
Write-Host "StoreNr   : $storeNumber"
Write-Host "WorkstationId: $workstationId"
Write-Host "-------------------"

# After the basic configuration section, update the onboarding call
Write-Host "Starting onboarding process for $ComponentType"

# Skip onboarding and store initialization if this is an update
if (-not $isUpdate) {
    # Call the onboarding script with the appropriate component type and tenant_id
    try {
        .\onboarding.ps1 -ComponentType $ComponentType -base_url $base_url -tenant_id $tenantId
        Write-Host "$ComponentType onboarding completed successfully"

        # Execute store initialization right after successful onboarding
        # Run store initialization for all components including WDM
        Write-Host "Starting store initialization..."
        $storeInitScript = Join-Path $PSScriptRoot "store-initialization.ps1"
        if (Test-Path $storeInitScript) {
            try {
                # Update get_store.json with the store ID
                $getStoreJsonPath = Join-Path $PSScriptRoot "helper\init\get_store.json"
                if (Test-Path $getStoreJsonPath) {
                    Write-Host "Creating processed copy of get_store.json with Store ID: $storeNumber"
                    # Create directory if it doesn't exist
                    $initPath = Join-Path $PSScriptRoot "helper\init"
                    if (-Not (Test-Path $initPath)) {
                        New-Item -ItemType Directory -Path $initPath -Force | Out-Null
                    }
                    # Create processed copy
                    $processedGetStorePath = Join-Path $initPath "get_store_processed.json"
                    # Read the original file
                    $getStoreJson = Get-Content -Path $getStoreJsonPath -Raw
                    # Replace the placeholder in memory
                    $processedGetStoreJson = $getStoreJson -replace '@RETAIL_STORE_ID@', $storeNumber
                    # Save to the processed file
                    Set-Content -Path $processedGetStorePath -Value $processedGetStoreJson
                    Write-Host "get_store_processed.json created successfully"
                } else {
                    Write-Host "Warning: get_store.json not found at: $getStoreJsonPath"
                }

                # Update StoreHub configuration with dynamic version if this is a StoreHub installation
                if ($ComponentType -eq "STOREHUB-SERVICE") {
                    $storehubConfigPath = Join-Path $PSScriptRoot "helper\init\storehub\update_config.json"
                    if (Test-Path $storehubConfigPath) {
                        Write-Host "Updating StoreHub configuration with dynamic version: $component_version"
                        # Create a backup of the original
                        $backupPath = "$storehubConfigPath.backup"
                        Copy-Item -Path $storehubConfigPath -Destination $backupPath -Force
                        # Create a processed copy with the dynamic version
                        $processedStorehubConfigPath = Join-Path $PSScriptRoot "helper\init\storehub\update_config_processed.json"
                        $storehubConfig = Get-Content -Path $storehubConfigPath -Raw
                        # Replace the version placeholder with the dynamic version
                        $processedStorehubConfig = $storehubConfig -replace '@SYSTEM_VERSION@', $component_version
                        Set-Content -Path $processedStorehubConfigPath -Value $processedStorehubConfig
                        Write-Host "StoreHub configuration updated with version: $component_version"
                    } else {
                        Write-Host "Warning: StoreHub config not found at: $storehubConfigPath"
                    }
                }

                # Pass the values collected from hostname or user input with the dynamic version
                & $storeInitScript -ComponentType $ComponentType -base_url $base_url -StoreId $storeNumber -WorkstationId $workstationId -Version $component_version
                if ($LASTEXITCODE -eq 0) {
                    Write-Host "Store initialization completed successfully"
                } else {
                    Write-Host "Warning: Store initialization failed with exit code $LASTEXITCODE"
                    Stop-TranscriptSafely
                    exit 1
                }
            }
            catch {
                Write-Host "Error during store initialization: $_"
                Stop-TranscriptSafely
                exit 1
            }
        } else {
            Write-Host "Error: Store initialization script not found at: $storeInitScript"
            Stop-TranscriptSafely
            exit 1
        }
    }
    catch {
        Write-Host "Error during $ComponentType onboarding: $_"
        Stop-TranscriptSafely
        exit 1
    }
} else {
    Write-Host "Skipping onboarding and store initialization for update"
}

# Read onboarding token
$onboardingToken = ""
if (-not $isUpdate) {
    $onboardingTokenPath = "onboarding.token"
    if (-not (Test-Path $onboardingTokenPath)) {
        Write-Host "Error: Onboarding token file not found at: $onboardingTokenPath"
        Stop-TranscriptSafely
        exit 1
    }
    $onboardingToken = Get-Content -Path $onboardingTokenPath -Raw
    $onboardingToken = $onboardingToken.Trim()
} else {
    Write-Host "Skipping onboarding token check for update mode"
    $onboardingToken = "not-required-for-update"
}

# Create configuration files
$installationToken = @'
configService.url=https://@Server@/api/config
cims.url=https://@Server@/api/iam/cim/rest
station.tenantId=@TenantId@
station.storeId=@StoreNr@
station.workstationId=@WorkstationId@
station.applicationVersion=@Version@
station.systemType=@SYSTEM_TYPE@
onboarding.token=@ONBOARDING_TOKEN@
dsg.url=https://@DsgServer@/api/digital-content/content/cep/SoftwarePackage
'@

$installationToken = $installationToken.Replace('@StoreNr@', $storeNumber)
$installationToken = $installationToken.Replace('@WorkstationId@', $workstationId)
$installationToken = $installationToken.Replace('@Version@', $component_version)
$installationToken = $installationToken.Replace('@Server@', $server)
$installationToken = $installationToken.Replace('@DsgServer@', $dsg_server)
$installationToken = $installationToken.Replace('@SYSTEM_TYPE@', $systemType)
$installationToken = $installationToken.Replace('@ONBOARDING_TOKEN@', $onboardingToken)
$installationToken = $installationToken.Replace('@TenantId@', $tenantId)

# Resolve RCS URL if autodetect requested
if ($rcsUrl -eq "autodetect") {
    Write-Host "Autodetecting RCS URL from config-service..." -ForegroundColor Cyan
    $rcsUrl = ""  # Reset so we only append if fetch succeeds
    try {
        $tokenFile = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
        if (Test-Path $tokenFile) {
            $bearerToken = (Get-Content $tokenFile -Raw).Trim()
            $rcsHeaders = @{
                "authorization" = "Bearer $bearerToken"
                "Content-Type"  = "application/json"
            }

            # Call 1: Get child nodes for this store
            $childNodesUrl = "https://$server/api/config/services/rest/infrastructure/v1/structure/child-nodes/search"
            $childNodesBody = @{
                station = @{
                    systemName    = "GKR-Store"
                    tenantId      = $tenantId
                    retailStoreId = $storeNumber
                }
            } | ConvertTo-Json -Compress
            Write-Host "Fetching store child nodes for store $storeNumber..."
            $childNodesResponse = Invoke-RestMethod -Uri $childNodesUrl -Method Post -Headers $rcsHeaders -Body $childNodesBody -TimeoutSec 30

            # Find the RCS node
            $rcsNode = $childNodesResponse.childNodeList | Where-Object { $_.systemName -like "*Resource-Cache-Service*" } | Select-Object -First 1
            if ($rcsNode) {
                Write-Host "Found RCS node: $($rcsNode.systemName) (version: $($rcsNode.activeVersion))"

                # Call 2: Get system.properties for the RCS node
                $paramUrl = "https://$server/api/config/services/rest/config-management/v1/parameter-contents/plain/search"
                $paramBody = @{
                    levelDescriptor  = @{ structureUniqueName = $rcsNode.structureUniqueName }
                    systemDescriptor = @{
                        systemName        = $rcsNode.systemName
                        systemVersionList = @(@{ name = $rcsNode.activeVersion })
                    }
                    parameterList    = @(@{ name = "system.properties" })
                } | ConvertTo-Json -Depth 4 -Compress
                Write-Host "Fetching RCS system.properties..."
                $paramResponse = Invoke-RestMethod -Uri $paramUrl -Method Post -Headers $rcsHeaders -Body $paramBody -ContentType "application/json" -TimeoutSec 30

                # Decode base64 content and extract rcs.url
                $propsParam = $paramResponse.parameterList | Where-Object { $_.name -eq "system.properties" } | Select-Object -First 1
                if ($propsParam -and $propsParam.content) {
                    $propsContent = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($propsParam.content))
                    # Parse rcs.url from properties (handle Java-style escaping \: -> :)
                    $rcsUrlMatch = [regex]::Match($propsContent, 'rcs\.url\s*=\s*(.+)')
                    if ($rcsUrlMatch.Success) {
                        $rcsUrl = $rcsUrlMatch.Groups[1].Value.Trim() -replace '\\:', ':' -replace '\\=', '='
                        Write-Host "Autodetected RCS URL: $rcsUrl" -ForegroundColor Green
                    } else {
                        Write-Host "Warning: system.properties found but no rcs.url entry" -ForegroundColor Yellow
                    }
                } else {
                    Write-Host "Warning: No system.properties content returned for RCS node" -ForegroundColor Yellow
                }
            } else {
                Write-Host "Warning: No Resource-Cache-Service node found for store $storeNumber" -ForegroundColor Yellow
            }
        } else {
            Write-Host "Warning: No access token available for RCS URL autodetect" -ForegroundColor Yellow
        }
    } catch {
        Write-Host "Warning: Failed to autodetect RCS URL: $_" -ForegroundColor Yellow
    }

    if ([string]::IsNullOrEmpty($rcsUrl)) {
        Write-Host "RCS URL autodetection failed. Continue without rcs.url in installation token?" -ForegroundColor Yellow
        $continue = Read-Host "Press Y to continue, any other key to abort"
        if ($continue -ne "Y" -and $continue -ne "y") {
            Write-Host "Aborted by user."
            Stop-TranscriptSafely
            exit 1
        }
    }
}

# Append RCS URL to installation token if provided
if ($rcsUrl -and $rcsUrl -ne "autodetect") {
    $installationToken += "`nrcs.url=$rcsUrl"
}

Set-Content -Path "installationtoken.txt" -Value $installationToken

# Create base64 token
$bytes = [System.Text.Encoding]::UTF8.GetBytes($installationToken)
$base64Token = [Convert]::ToBase64String($bytes)
Set-Content -Path "installationtoken.base64" -Value $base64Token

# Create addonpack.properties
$addonpackProps = @'
dsg.addonpack.url=https://@DSG_SERVER@/dsg/content/cep/AddOnPacks
addonpacks=
'@
$addonpackProps = $addonpackProps.Replace('@DSG_SERVER@', $dsg_server)
Set-Content -Path "$install_dir\addonpack.properties" -Value $addonpackProps

# Only handle .p12 certificates for non-POS installations
if ($ComponentType -ne 'POS') {
    # Handle .p12 file if it exists
    $p12Files = Get-ChildItem -Path "." -Filter "*.p12"

    # Create security directory if it doesn't exist
    if (-not (Test-Path $security_dir)) {
        Write-Host "Creating security directory: $security_dir"
        New-Item -ItemType Directory -Path $security_dir -Force | Out-Null
    }

    # Check for certificates in the security directory
    $securityP12Files = Get-ChildItem -Path $security_dir -Filter "*.p12" -ErrorAction SilentlyContinue
    $ssl_path = $null

    # Check for certificates in the current directory
    $usedExistingCert = $false

    if ($p12Files.Count -gt 0) {
    Write-Host "Found .p12 file(s) in script directory"
    
    # Check if we have certificates in security directory
    if ($securityP12Files.Count -gt 0) {
        Write-Host "Found existing certificate(s) in security directory, checking for name matches..."
        
        # Get certificate names from security directory
        $securityCertNames = $securityP12Files | ForEach-Object { $_.Name }
        
        # Check if any of our current certificates match by name
        $matchingCert = $p12Files | Where-Object { $securityCertNames -contains $_.Name } | Select-Object -First 1
        
        if ($matchingCert) {
            # Use the matching certificate from security directory
            $ssl_path = ($securityP12Files | Where-Object { $_.Name -eq $matchingCert.Name } | Select-Object -First 1).FullName
            Write-Host "Using existing certificate with matching name: $($matchingCert.Name) from security directory"
            $usedExistingCert = $true
        } else {
            # No matching certificate found, copy and use the new one
            Write-Host "Certificate in current directory has different name than existing ones, copying and using new certificate"
            
            # Copy the first p12 file found if there are multiple
            $newCert = $p12Files[0]
            $destPath = Join-Path $security_dir $newCert.Name
            Write-Host "Copying $($newCert.Name) to $destPath"
            Copy-Item -Path $newCert.FullName -Destination $destPath -Force
            
            # Use the newly copied certificate
            $ssl_path = $destPath
        }
    } else {
        # No certificates in security directory, copy all from current directory
        Write-Host "No certificates in security directory, copying all from current directory"
        
        # Copy each .p12 file found
        foreach ($p12File in $p12Files) {
            # Copy with original filename
            $destPath = Join-Path $security_dir $p12File.Name
            Write-Host "Copying $($p12File.Name) to $destPath"
            Copy-Item -Path $p12File.FullName -Destination $destPath -Force
            
            # Set the ssl_path to the first certificate copied
            if ($null -eq $ssl_path) {
                $ssl_path = $destPath
            }
        }
    }
} elseif ($securityP12Files.Count -gt 0) {
    # No certificates in current directory but some in security directory
    # Use the first .p12 file found in the security directory
    $ssl_path = $securityP12Files[0].FullName
    Write-Host "Found certificate at: $ssl_path"
    $usedExistingCert = $true
    } else {
        # No certificate found anywhere
        Write-Host "Warning: No certificate found for Tomcat. The installation may fail if a certificate is required."
    }
}

# Paths
$launchersPath = Join-Path $PSScriptRoot "helper\launchers"

# Verify launchers path exists
if (-Not (Test-Path $launchersPath)) {
    Write-Host "Launchers path does not exist: $launchersPath"
    exit
}

# Select the appropriate template file
$templateFile = if ($ComponentType -eq 'POS') {
    Join-Path $launchersPath "launcher.pos.template"
} elseif ($ComponentType -eq 'ONEX-POS') {
    Join-Path $launchersPath "launcher.onex-pos.template"
} elseif ($ComponentType -eq 'WDM') {
    Join-Path $launchersPath "launcher.wdm.template"
} elseif ($ComponentType -eq 'FLOW-SERVICE') {
    Join-Path $launchersPath "launcher.flow-service.template"
} elseif ($ComponentType -eq 'LPA-SERVICE') {
    Join-Path $launchersPath "launcher.lpa-service.template"
} elseif ($ComponentType -eq 'STOREHUB-SERVICE') {
    Join-Path $launchersPath "launcher.storehub-service.template"
} elseif ($ComponentType -eq 'RCS-SERVICE') {
    Join-Path $launchersPath "launcher.rcs-service.template"
} else {
    Join-Path $launchersPath "launcher.wdm.template"
}

if (-not (Test-Path $templateFile)) {
    Write-Host "Error: Template file $templateFile not found"
    exit 1
}

# Read the template content
$launcherProps = Get-Content -Path $templateFile -Raw

# Prepare replacement values (avoid complex expressions in hashtable for PS 5.1)
if ($offline_mode) { $offline_mode_value = "1" } else { $offline_mode_value = "0" }
if ($offline_mode -and -not [string]::IsNullOrEmpty($jre_version)) { $jre_version_value = $jre_version } else { $jre_version_value = "" }
if ($offline_mode -and $jre_files.Count -gt 0) { $jre_package_value = $jre_files[0].FullName } else { $jre_package_value = "" }
if ($offline_mode -and $has_installer_jar) { $installer_package_value = $installer_jar } else { $installer_package_value = "" }
if ($offline_mode -and $has_ui_package) { $ui_package_value = $ui_package } else { $ui_package_value = "" }

# Replace placeholders with actual values
$replacements = @{
    '@INSTALL_DIR@' = $install_dir
    '@BASE64_TOKEN@' = $base64Token
    '@OFFLINE_MODE@' = $offline_mode_value
    '@JRE_VERSION@' = $jre_version_value
    '@JRE_PACKAGE@' = $jre_package_value
    '@INSTALLER_PACKAGE@' = $installer_package_value
    '@UI_PACKAGE@' = $ui_package_value
    '@SSL_PATH@' = $ssl_path
    '@SSL_PASSWORD@' = $ssl_password
    '@FIREBIRD_SERVER_PATH@' = $firebird_server_path
    '@FIREBIRD_DRIVER_PATH_LOCAL@' = $firebird_driver_path_local
}

# Add Tomcat replacements if Tomcat files were found
if ($tomcat_files.Count -gt 0) {
    if ($offline_mode) { $tomcat_version_value = $tomcat_version } else { $tomcat_version_value = "" }
    if ($offline_mode) { $tomcat_package_value = $tomcat_files[0].FullName } else { $tomcat_package_value = "" }
    $replacements['@TOMCAT_VERSION@'] = $tomcat_version_value
    $replacements['@TOMCAT_PACKAGE@'] = $tomcat_package_value
}

# Add Jaybird driver path if found
if ($has_jaybird) {
    $replacements['@FIREBIRD_DRIVER_PATH_LOCAL@'] = $firebird_driver_path_local
}

# Apply all replacements
foreach ($key in $replacements.Keys) {
    $launcherProps = $launcherProps.Replace($key, $replacements[$key])
}

Write-Host "Writing launcher properties to file..."
Set-Content -Path "launcher.properties" -Value $launcherProps -Force
Write-Host "Launcher properties file created successfully. Launcher will use this for configuration."

# Deploy installer override file
$removeOverridesAfterInstall = "@REMOVE_OVERRIDES_AFTER_INSTALL@"
if ($noOverrides) {
    Write-Host "Skipping installer overrides (--noOverrides flag specified)"
} else {
    $overridesDir = Join-Path $PSScriptRoot "helper\overrides"
    $overrideFile = switch ($ComponentType) {
        'POS'              { "installer_overrides.pos.xml" }
        'ONEX-POS'         { "installer_overrides.onex-pos.xml" }
        'WDM'              { "installer_overrides.wdm.xml" }
        'FLOW-SERVICE'     { "installer_overrides.flow-service.xml" }
        'LPA-SERVICE'      { "installer_overrides.lpa-service.xml" }
        'STOREHUB-SERVICE' { "installer_overrides.storehub-service.xml" }
        'RCS-SERVICE'      { "installer_overrides.rcs-service.xml" }
        default            { $null }
    }
    if ($overrideFile) {
        $overrideSource = Join-Path $overridesDir $overrideFile
        if (Test-Path $overrideSource) {
            $overrideDest = Join-Path $install_dir "installer\overrides"
            New-Item -ItemType Directory -Path $overrideDest -Force | Out-Null
            $overrideXmlPath = Join-Path $overrideDest "installer_overrides.xml"
            Copy-Item -Path $overrideSource -Destination $overrideXmlPath -Force
            Write-Host "Deployed installer override file to: $overrideXmlPath"

            # Apply CLI overrides to the deployed XML
            if ($skipCheckAlive -or $skipStartApplication) {
                $xmlContent = Get-Content -Path $overrideXmlPath -Raw
                if ($skipCheckAlive) {
                    $xmlContent = $xmlContent -replace '("override\.check-alive" value=")false(")', '${1}true${2}'
                    Write-Host "CLI Override: check-alive set to true (will be skipped)"
                }
                if ($skipStartApplication) {
                    $xmlContent = $xmlContent -replace '("override\.start-application" value=")false(")', '${1}true${2}'
                    Write-Host "CLI Override: start-application set to true (will be skipped)"
                }
                $xmlContent | Set-Content -Path $overrideXmlPath -NoNewline
            }
        } else {
            Write-Host "Warning: Override source file not found: $overrideSource"
        }
    }
}

# Download or use local Launcher
if (-not $offline_mode) {
    $download_url = "https://$base_url/dsg/content/cep/SoftwarePackage/$systemType/$component_version/Launcher.exe"
    Write-Host "Attempting to download Launcher.exe from: $download_url"
    try {
        # Try to use curl first (faster), fall back to WebClient if not available or fails
        if (Get-Command curl.exe -ErrorAction SilentlyContinue) {
            Write-Host "Using curl for download..."
            try {
                curl.exe -k -L --progress-bar --ssl-no-revoke -o "Launcher.exe" "$download_url"
                if (-not (Test-Path "Launcher.exe") -or (Get-Item "Launcher.exe").Length -eq 0) {
                    throw "Curl download failed or produced empty file."
                }
                Write-Host "Successfully downloaded Launcher.exe using curl"
            } catch {
                Write-Host "Curl failed: $_. Falling back to WebClient..."
                $webClient = New-Object System.Net.WebClient
                $webClient.DownloadFile($download_url, "Launcher.exe")
            }
        } else {
            Write-Host "curl not available, using WebClient..."
            $webClient = New-Object System.Net.WebClient
            $webClient.DownloadFile($download_url, "Launcher.exe")
        }
        Write-Host "Successfully downloaded Launcher.exe"
    }
    catch {
        Write-Host "Error downloading Launcher.exe: $_"
        Stop-TranscriptSafely
        exit 1
    }
} else {
    # In offline mode, copy the Launcher.exe from the package directory to the current directory
    Write-Host "Copying Launcher.exe from $package_dir to current directory..."
    try {
        Copy-Item -Path $launcher_path -Destination ".\Launcher.exe" -Force
        Write-Host "Successfully copied Launcher.exe"
    }
    catch {
        Write-Host "Error copying Launcher.exe: $_"
        Stop-TranscriptSafely
        exit 1
    }
}

# Start the installation
Write-Host "Starting installation..."

# Check if installer log already exists and delete it
$installerLogPath = Join-Path $install_dir "installer\log\installer.log"
if (Test-Path $installerLogPath) {
    Write-Host "Found existing installer log file. Deleting to ensure clean installation..."
    try {
        Remove-Item -Path $installerLogPath -Force
        Write-Host "Existing installer log file deleted successfully."
    } catch {
        Write-Host "Warning: Failed to delete existing installer log file: $_"
        Write-Host "This might lead to confusing log output during installation."
    }
}

# Start Launcher with appropriate arguments for new installation or update
if ($isUpdate) {
    Write-Host "================================================================="
    Write-Host "                     RUNNING IN UPDATE MODE                      " -ForegroundColor Cyan
    Write-Host "================================================================="
    $launchArgs = @(
        "--mode", "unattended",
        "--forceDownload", "false",
        "--station.applicationVersion", $component_version,
        "--station.propertiesPath", $install_dir
    )
    Write-Host "Running Launcher with update arguments: $($launchArgs -join ' ')"
    $launcherProcess = Start-Process -FilePath ".\Launcher.exe" -ArgumentList $launchArgs -PassThru
} else {
    Write-Host "================================================================="
    Write-Host "                 RUNNING IN FULL INSTALLATION MODE               " -ForegroundColor Green
    Write-Host "================================================================="
    $launcherProcess = Start-Process -FilePath ".\Launcher.exe" -ArgumentList "--defaultsFile", "launcher.properties", "--mode", "unattended" -PassThru
}

# Check installation logs
$maxWaitTime = 7200 # 2 hours timeout
$maxLogWaitTime = 3600 # 1 hour timeout for download installers from DSG
$elapsed = 0
$logWaitElapsed = 0
$checkInterval = 2 # Check every 2 seconds
$lastLineNumber = 0
$firstLog = $true

Write-Host "Waiting for installation to complete..."
Write-Host "Monitoring log: $installerLogPath"

while ($elapsed -lt $maxWaitTime) {
    # Check if launcher is still running
    if ($launcherProcess.HasExited) {
        Write-Host "Launcher process has exited with code: $($launcherProcess.ExitCode)"
        Write-Host "Continuing to monitor logs for 5 seconds..."
        
        $postExitTime = 5
        while ($postExitTime -gt 0) {
            if (Test-Path $installerLogPath) {
                try {
                    # Read new lines from the log
                    $currentContent = Get-Content $installerLogPath -ErrorAction Stop
                    
                    if ($currentContent.Count -gt $lastLineNumber) {
                        $newLines = $currentContent[$lastLineNumber..($currentContent.Count-1)]
                        foreach ($line in $newLines) {
                            Write-Host "LOG: $line"
                        }
                        $lastLineNumber = $currentContent.Count
                    }
                }
                catch {
                    Write-Host "Error reading log file: $_"
                }
            }
            
            Write-Host -NoNewline "`rTime remaining for log monitoring: $postExitTime seconds..."
            Start-Sleep -Seconds 1
            $postExitTime--
        }
        Write-Host "`nCompleting installation..."
        
        # Final log check
        if (Test-Path $installerLogPath) {
            try {
                $finalLogContent = Get-Content $installerLogPath -ErrorAction Stop | Select-Object -Last 20
                if ($finalLogContent -match "Installation finished") {
                    Write-Host "Installation completed successfully!"
                    Write-Host "Installation directory: $install_dir"

                    # Remove installer overrides if configured
                    if ($removeOverridesAfterInstall -eq "true") {
                        $overrideDest = Join-Path $install_dir "installer\overrides"
                        if (Test-Path $overrideDest) {
                            Remove-Item -Path $overrideDest -Recurse -Force
                            Write-Host "Removed installer overrides folder: $overrideDest"
                        }
                    }

                    # Component-specific completion messages
                    Write-Host "$ComponentType installation has been completed successfully." -ForegroundColor Green

                    # Cleanup: Move generated files to a results directory
                    $resultsDir = "results_$ComponentType"
                    Write-Host "Performing cleanup - Moving generated files to $resultsDir directory..."
                    
                    # Create the results directory if it doesn't exist
                    if (-not (Test-Path $resultsDir)) {
                        New-Item -ItemType Directory -Path $resultsDir -Force | Out-Null
                    }
                    
                    # Multiple attempts to ensure transcript is stopped
                    Write-Host "Making multiple attempts to stop the transcript before cleanup..."
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 1
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 1
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 2
                    
                    # List of files to move
                    $filesToMove = @(
                        "installationtoken.txt",
                        "installationtoken.base64",
                        "launcher.properties",
                        "onboarding.token",
                        "Launcher.exe"
                    )
                    
                    # Add additional files specific to the installation - but only if they exist
                    $additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
                    if ($additionalFiles) {
                        foreach ($logFile in $additionalFiles) {
                            $filesToMove += $logFile.FullName
                        }
                    }
                    
                    # Find all JSON files in the current directory and helper subdirectories
                    $jsonFiles = @()
                    # Only include JSON files in the current directory, not in helper
                    $jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue
                    
                    if ($jsonFiles.Count -gt 0) {
                        Write-Host "Found $($jsonFiles.Count) JSON files to move"
                        foreach ($jsonFile in $jsonFiles) {
                            $filesToMove += $jsonFile.FullName
                        }
                    } else {
                        Write-Host "No JSON files need to be cleaned up"
                    }

                    # Move each file to the results directory
                    foreach ($file in $filesToMove) {
                        if (Test-Path $file) {
                            # Skip any files in helper directory
                            if ($file -like "*\helper\*") {
                                continue
                            }
                            
                            # Process only files in current directory
                            $destFile = Join-Path $resultsDir (Split-Path -Leaf $file)
                            
                            try {
                                # Copy first, then remove to ensure successful copy
                                Copy-Item -Path $file -Destination $destFile -Force
                                Write-Host "Moved: $file to $destFile"
                                Remove-Item -Path $file -Force
                            } catch {
                                Write-Host "Warning: Could not process $file to results directory: $_"
                            }
                        }
                    }
                    
                    # Final attempt to stop transcript and handle log file as last step
                    Write-Host "Performing final transcript stop and log file cleanup..."
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 1
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 1
                    try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                    Start-Sleep -Seconds 2
                    
                    # Move log file to results directory if it exists
                    if (Test-Path $logFile) {
                        $destLogFile = Join-Path $resultsDir $logFile
                        try {
                            Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
                            Write-Host "Copying log file: $logFile to $destLogFile"
                            Copy-Item -Path $logFile -Destination $destLogFile -Force
                            Write-Host "Console output log copied to: $destLogFile"
                            
                            # Try to remove original but don't fail if it can't be deleted
                            try {
                                Write-Host "Attempting to remove original log file..."
                                Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
                                Write-Host "Original log file removed successfully."
                            } catch {
                                Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
                            }
                        } catch {
                            Write-Host "Warning: Could not copy log file to results directory: $_"
                        }
                    }

                    Write-Host "Cleanup completed. Installation files have been moved to $resultsDir directory."

                    # Final cleanup operations before exiting
                    Write-Host "Executing final cleanup before exit..."

                    # Clean up access token
                    $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
                    if (Test-Path $tokenPath) {
                        Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
                    }

                    [System.GC]::Collect()  # Force garbage collection
                    Start-Sleep -Seconds 1  # Give GC time to work

                    exit 0
                }
                elseif ($finalLogContent -match "Installation failed") {
                    Write-Host "Installation failed. Please check the logs at: $installerLogPath"
                    exit 1
                }
            }
            catch {
                Write-Host "Error reading final log state: $_"
            }
        }
        
        # If we couldn't determine status from logs, use process exit code
        if ($launcherProcess.ExitCode -eq 0) {
            Write-Host "Launcher completed successfully based on exit code."
            Write-Host "Installation directory: $install_dir"
            
            # Cleanup: Move generated files to a results directory
            $resultsDir = "results_$ComponentType"
            Write-Host "Performing cleanup - Moving generated files to $resultsDir directory..."
            
            # Create the results directory if it doesn't exist
            if (-not (Test-Path $resultsDir)) {
                New-Item -ItemType Directory -Path $resultsDir -Force | Out-Null
            }
            
            # Multiple attempts to ensure transcript is stopped
            Write-Host "Making multiple attempts to stop the transcript before cleanup..."
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 2
            
            # List of files to move
            $filesToMove = @(
                "installationtoken.txt",
                "installationtoken.base64",
                "launcher.properties",
                "onboarding.token",
                "Launcher.exe"
            )
            
            # Add additional files specific to the installation - but only if they exist
            $additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
            if ($additionalFiles) {
                foreach ($logFile in $additionalFiles) {
                    $filesToMove += $logFile.FullName
                }
            }
            
            # Find all JSON files in the current directory and helper subdirectories
            $jsonFiles = @()
            # Only include JSON files in the current directory, not in helper
            $jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue
            
            if ($jsonFiles.Count -gt 0) {
                Write-Host "Found $($jsonFiles.Count) JSON files to move"
                foreach ($jsonFile in $jsonFiles) {
                    $filesToMove += $jsonFile.FullName
                }
            } else {
                Write-Host "No JSON files need to be cleaned up"
            }

            # Move each file to the results directory
            foreach ($file in $filesToMove) {
                if (Test-Path $file) {
                    # Skip any files in helper directory
                    if ($file -like "*\helper\*") {
                        continue
                    }
                    
                    # Process only files in current directory
                    $destFile = Join-Path $resultsDir (Split-Path -Leaf $file)
                    
                    try {
                        # Copy first, then remove to ensure successful copy
                        Copy-Item -Path $file -Destination $destFile -Force
                        Write-Host "Moved: $file to $destFile"
                        Remove-Item -Path $file -Force
                    } catch {
                        Write-Host "Warning: Could not process $file to results directory: $_"
                    }
                }
            }
            
            # Final attempt to stop transcript and handle log file as last step
            Write-Host "Performing final transcript stop and log file cleanup..."
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 2
            
            # Move log file to results directory if it exists
            if (Test-Path $logFile) {
                $destLogFile = Join-Path $resultsDir $logFile
                try {
                    Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
                    Write-Host "Copying log file: $logFile to $destLogFile"
                    Copy-Item -Path $logFile -Destination $destLogFile -Force
                    Write-Host "Console output log copied to: $destLogFile"
                    
                    # Try to remove original but don't fail if it can't be deleted
                    try {
                        Write-Host "Attempting to remove original log file..."
                        Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
                        Write-Host "Original log file removed successfully."
                    } catch {
                        Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
                    }
                } catch {
                    Write-Host "Warning: Could not copy log file to results directory: $_"
                }
            }

            # Clean up access token
            $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
            if (Test-Path $tokenPath) {
                Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
            }

            exit 0
        } else {
            Write-Host "Launcher failed with exit code: $($launcherProcess.ExitCode)"
            Write-Host "Please check the logs at: $installerLogPath"
            
            # Cleanup for failed installation - move files to errors directory
            $errorsDir = "errors_$ComponentType"
            Write-Host "Performing cleanup for failed installation - Moving files to $errorsDir directory..."
            
            # Create the errors directory if it doesn't exist
            if (-not (Test-Path $errorsDir)) {
                New-Item -ItemType Directory -Path $errorsDir -Force | Out-Null
            }
            
            # Multiple attempts to ensure transcript is stopped
            Write-Host "Making multiple attempts to stop the transcript before cleanup..."
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 2
            
            # List of files to move
            $filesToMove = @(
                "installationtoken.txt",
                "installationtoken.base64",
                "launcher.properties",
                "onboarding.token",
                "Launcher.exe"
            )
            
            # Add additional files specific to the installation - but only if they exist
            $additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
            if ($additionalFiles) {
                foreach ($logFile in $additionalFiles) {
                    $filesToMove += $logFile.FullName
                }
            }
            
            # Find all JSON files in the current directory and helper subdirectories
            $jsonFiles = @()
            # Only include JSON files in the current directory, not in helper
            $jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue
            
            if ($jsonFiles.Count -gt 0) {
                Write-Host "Found $($jsonFiles.Count) JSON files to move"
                foreach ($jsonFile in $jsonFiles) {
                    $filesToMove += $jsonFile.FullName
                }
            } else {
                Write-Host "No JSON files need to be cleaned up"
            }

            # Move each file to the errors directory
            foreach ($file in $filesToMove) {
                if (Test-Path $file) {
                    # Skip any files in helper directory
                    if ($file -like "*\helper\*") {
                        continue
                    }
                    
                    # Process only files in current directory
                    $destFile = Join-Path $errorsDir (Split-Path -Leaf $file)
                    
                    try {
                        # Copy first, then remove to ensure successful copy
                        Copy-Item -Path $file -Destination $destFile -Force
                        Write-Host "Moved: $file to $destFile"
                        Remove-Item -Path $file -Force
                    } catch {
                        Write-Host "Warning: Could not process $file to errors directory: $_"
                    }
                }
            }
            
            # Final attempt to stop transcript and handle log file as last step
            Write-Host "Performing final transcript stop and log file cleanup..."
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 2
            
            # Move log file to errors directory if it exists
            if (Test-Path $logFile) {
                $destLogFile = Join-Path $errorsDir $logFile
                try {
                    Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
                    Write-Host "Copying log file: $logFile to $destLogFile"
                    Copy-Item -Path $logFile -Destination $destLogFile -Force
                    Write-Host "Console output log copied to: $destLogFile"
                    
                    # Try to remove original but don't fail if it can't be deleted
                    try {
                        Write-Host "Attempting to remove original log file..."
                        Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
                        Write-Host "Original log file removed successfully."
                    } catch {
                        Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
                    }
                } catch {
                    Write-Host "Warning: Could not copy log file to errors directory: $_"
                }
            }
            
            Write-Host "Cleanup completed. Failed installation files have been moved to $errorsDir directory."
            
            # Final attempt to stop transcript before exit
            Write-Host "Performing final transcript stop before exit..."
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 1
            try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
            Start-Sleep -Seconds 2

            # Clean up access token
            $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
            if (Test-Path $tokenPath) {
                Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
            }

            exit 1
        }
    }

    if (Test-Path $installerLogPath) {
        try {
            # First time we see the log file
            if ($firstLog) {
                Write-Host "Log file created at: $installerLogPath"
                $firstLog = $false
            }

            # Read new lines from the log
            $currentContent = Get-Content $installerLogPath -ErrorAction Stop
            
            if ($currentContent.Count -gt $lastLineNumber) {
                $newLines = $currentContent[$lastLineNumber..($currentContent.Count-1)]
                foreach ($line in $newLines) {
                    Write-Host "LOG: $line"
                }
                $lastLineNumber = $currentContent.Count
            }

            # Check for completion
            $logContent = $currentContent | Select-Object -Last 20
            if ($logContent -match "Installation finished") {
                Write-Host "Installation completed successfully!"
                Write-Host "Installation directory: $install_dir"

                # Remove installer overrides if configured
                if ($removeOverridesAfterInstall -eq "true") {
                    $overrideDest = Join-Path $install_dir "installer\overrides"
                    if (Test-Path $overrideDest) {
                        Remove-Item -Path $overrideDest -Recurse -Force
                        Write-Host "Removed installer overrides folder: $overrideDest"
                    }
                }

                # Component-specific completion messages
                Write-Host "$ComponentType installation has been completed successfully." -ForegroundColor Green

                # Cleanup: Move generated files to a results directory
                $resultsDir = "results_$ComponentType"
                Write-Host "Performing cleanup - Moving generated files to $resultsDir directory..."
                
                # Create the results directory if it doesn't exist
                if (-not (Test-Path $resultsDir)) {
                    New-Item -ItemType Directory -Path $resultsDir -Force | Out-Null
                }
                
                # Multiple attempts to ensure transcript is stopped
                Write-Host "Making multiple attempts to stop the transcript before cleanup..."
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 2
                
                # List of files to move
                $filesToMove = @(
                    "installationtoken.txt",
                    "installationtoken.base64",
                    "launcher.properties",
                    "onboarding.token",
                    "Launcher.exe"
                )
                
                # Add additional files specific to the installation - but only if they exist
                $additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
                if ($additionalFiles) {
                    foreach ($logFile in $additionalFiles) {
                        $filesToMove += $logFile.FullName
                    }
                }
                
                # Find all JSON files in the current directory and helper subdirectories
                $jsonFiles = @()
                # Only include JSON files in the current directory, not in helper
                $jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue
                
                if ($jsonFiles.Count -gt 0) {
                    Write-Host "Found $($jsonFiles.Count) JSON files to move"
                    foreach ($jsonFile in $jsonFiles) {
                        $filesToMove += $jsonFile.FullName
                    }
                } else {
                    Write-Host "No JSON files need to be cleaned up"
                }

                # Move each file to the results directory
                foreach ($file in $filesToMove) {
                    if (Test-Path $file) {
                        # Skip any files in helper directory
                        if ($file -like "*\helper\*") {
                            continue
                        }
                        
                        # Process only files in current directory
                        $destFile = Join-Path $resultsDir (Split-Path -Leaf $file)
                        
                        try {
                            # Copy first, then remove to ensure successful copy
                            Copy-Item -Path $file -Destination $destFile -Force
                            Write-Host "Moved: $file to $destFile"
                            Remove-Item -Path $file -Force
                        } catch {
                            Write-Host "Warning: Could not process $file to results directory: $_"
                        }
                    }
                }
                
                # Final attempt to stop transcript and handle log file as last step
                Write-Host "Performing final transcript stop and log file cleanup..."
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 2
                
                # Move log file to results directory if it exists
                if (Test-Path $logFile) {
                    $destLogFile = Join-Path $resultsDir $logFile
                    try {
                        Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
                        Write-Host "Copying log file: $logFile to $destLogFile"
                        Copy-Item -Path $logFile -Destination $destLogFile -Force
                        Write-Host "Console output log copied to: $destLogFile"
                        
                        # Try to remove original but don't fail if it can't be deleted
                        try {
                            Write-Host "Attempting to remove original log file..."
                            Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
                            Write-Host "Original log file removed successfully."
                        } catch {
                            Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
                        }
                    } catch {
                        Write-Host "Warning: Could not copy log file to results directory: $_"
                    }
                }
                
                Write-Host "Cleanup completed. Installation files have been moved to $resultsDir directory."

                # Final cleanup operations before exiting
                Write-Host "Executing final cleanup before exit..."

                # Clean up access token
                $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
                if (Test-Path $tokenPath) {
                    Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
                }

                [System.GC]::Collect()  # Force garbage collection
                Start-Sleep -Seconds 1  # Give GC time to work

                exit 0
            }
            elseif ($logContent -match "Installation failed") {
                Write-Host "Installation failed. Please check the logs at: $installerLogPath"
                
                # Cleanup for failed installation - move files to errors directory
                $errorsDir = "errors_$ComponentType"
                Write-Host "Performing cleanup for failed installation - Moving files to $errorsDir directory..."
                
                # Create the errors directory if it doesn't exist
                if (-not (Test-Path $errorsDir)) {
                    New-Item -ItemType Directory -Path $errorsDir -Force | Out-Null
                }
                
                # Multiple attempts to ensure transcript is stopped
                Write-Host "Making multiple attempts to stop the transcript before cleanup..."
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 2
                
                # List of files to move
                $filesToMove = @(
                    "installationtoken.txt",
                    "installationtoken.base64",
                    "launcher.properties",
                    "onboarding.token",
                    "Launcher.exe"
                )
                
                # Add additional files specific to the installation - but only if they exist
                $additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
                if ($additionalFiles) {
                    foreach ($logFile in $additionalFiles) {
                        $filesToMove += $logFile.FullName
                    }
                }
                
                # Find all JSON files in the current directory and helper subdirectories
                $jsonFiles = @()
                # Only include JSON files in the current directory, not in helper
                $jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue
                
                if ($jsonFiles.Count -gt 0) {
                    Write-Host "Found $($jsonFiles.Count) JSON files to move"
                    foreach ($jsonFile in $jsonFiles) {
                        $filesToMove += $jsonFile.FullName
                    }
                } else {
                    Write-Host "No JSON files need to be cleaned up"
                }

                # Move each file to the errors directory
                foreach ($file in $filesToMove) {
                    if (Test-Path $file) {
                        # Skip any files in helper directory
                        if ($file -like "*\helper\*") {
                            continue
                        }
                        
                        # Process only files in current directory
                        $destFile = Join-Path $errorsDir (Split-Path -Leaf $file)
                        
                        try {
                            # Copy first, then remove to ensure successful copy
                            Copy-Item -Path $file -Destination $destFile -Force
                            Write-Host "Moved: $file to $destFile"
                            Remove-Item -Path $file -Force
                        } catch {
                            Write-Host "Warning: Could not process $file to errors directory: $_"
                        }
                    }
                }
                
                # Final attempt to stop transcript and handle log file as last step
                Write-Host "Performing final transcript stop and log file cleanup..."
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 1
                try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
                Start-Sleep -Seconds 2
                
                # Move log file to errors directory if it exists
                if (Test-Path $logFile) {
                    $destLogFile = Join-Path $errorsDir $logFile
                    try {
                        Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
                        Write-Host "Copying log file: $logFile to $destLogFile"
                        Copy-Item -Path $logFile -Destination $destLogFile -Force
                        Write-Host "Console output log copied to: $destLogFile"
                        
                        # Try to remove original but don't fail if it can't be deleted
                        try {
                            Write-Host "Attempting to remove original log file..."
                            Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
                            Write-Host "Original log file removed successfully."
                        } catch {
                            Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
                        }
                    } catch {
                        Write-Host "Warning: Could not copy log file to errors directory: $_"
                    }
                }

                Write-Host "Cleanup completed. Failed installation files have been moved to $errorsDir directory."

                # Clean up access token
                $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
                if (Test-Path $tokenPath) {
                    Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
                }

                exit 1
            }
        }
        catch {
            Write-Host "Error reading log file: $_"
        }
    } else {
        $waitMessage = if (-not $offline.IsPresent) {
            "Waiting for installer log file to be created... ($logWaitElapsed seconds elapsed) - Downloading installation files from $base_url DSG"
        } else {
            "Waiting for installer log file to be created... ($logWaitElapsed seconds elapsed)"
        }
        Write-Host $waitMessage
        
        $logWaitElapsed += $checkInterval
        if ($logWaitElapsed -ge $maxLogWaitTime) {
            Write-Host "Error: Timeout waiting for installer log file to be created after $($maxLogWaitTime / 60) minutes"
            Write-Host "Expected log path: $installerLogPath"
            # Try to kill launcher process if it's still running
            if ($launcherProcess.HasExited -eq $false) {
                Write-Host "Terminating launcher process..."
                $launcherProcess.Kill()
            }

            # Clean up access token
            $tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
            if (Test-Path $tokenPath) {
                Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
            }

            Stop-TranscriptSafely
            exit 1
        }
    }
    
    Start-Sleep -Seconds $checkInterval
    $elapsed += $checkInterval
    
    # Show progress less frequently
    if ($elapsed % 30 -eq 0) {
        Write-Host "Installation in progress... ($(${elapsed}/60) minutes elapsed)"
    }
}

# Try to kill launcher process if it's still running after timeout
if (-not $launcherProcess.HasExited) {
    Write-Host "Terminating launcher process due to timeout..."
    $launcherProcess.Kill()
}

Write-Host "Warning: Installation timeout reached after 2 hours. Please check the installation logs at: $installerLogPath"
Write-Host "Installation directory: $install_dir"

# Cleanup for timeout failure
$errorsDir = "errors_$ComponentType"
Write-Host "Performing cleanup for timed out installation - Moving files to $errorsDir directory..."

# Create the errors directory if it doesn't exist
if (-not (Test-Path $errorsDir)) {
    New-Item -ItemType Directory -Path $errorsDir -Force | Out-Null
}

# Multiple attempts to ensure transcript is stopped
Write-Host "Making multiple attempts to stop the transcript before cleanup..."
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 1
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 1
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 2

# List of files to move
$filesToMove = @(
    "installationtoken.txt",
    "installationtoken.base64",
    "launcher.properties",
    "onboarding.token",
    "Launcher.exe"
)

# Add additional files specific to the installation - but only if they exist
$additionalFiles = Get-ChildItem -Path "." -Filter "*.log" -File -ErrorAction SilentlyContinue
if ($additionalFiles) {
    foreach ($logFile in $additionalFiles) {
        $filesToMove += $logFile.FullName
    }
}

# Find all JSON files in the current directory and helper subdirectories
$jsonFiles = @()
# Only include JSON files in the current directory, not in helper
$jsonFiles += Get-ChildItem -Path "." -Filter "*.json" -File -Depth 0 -ErrorAction SilentlyContinue

if ($jsonFiles.Count -gt 0) {
    Write-Host "Found $($jsonFiles.Count) JSON files to move"
    foreach ($jsonFile in $jsonFiles) {
        $filesToMove += $jsonFile.FullName
    }
} else {
    Write-Host "No JSON files need to be cleaned up"
}

# Move each file to the errors directory
foreach ($file in $filesToMove) {
    if (Test-Path $file) {
        # Skip any files in helper directory
        if ($file -like "*\helper\*") {
            continue
        }
        
        # Process only files in current directory
        $destFile = Join-Path $errorsDir (Split-Path -Leaf $file)
        
        try {
            # Copy first, then remove to ensure successful copy
            Copy-Item -Path $file -Destination $destFile -Force
            Write-Host "Moved: $file to $destFile"
            Remove-Item -Path $file -Force
        } catch {
            Write-Host "Warning: Could not process $file to errors directory: $_"
        }
    }
}

# Final attempt to stop transcript and handle log file as last step
Write-Host "Performing final transcript stop and log file cleanup..."
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 1
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 1
try { Stop-Transcript -ErrorAction SilentlyContinue } catch {}
Start-Sleep -Seconds 2

# Move log file to errors directory if it exists
if (Test-Path $logFile) {
    $destLogFile = Join-Path $errorsDir $logFile
    try {
        Start-Sleep -Seconds 3  # Longer pause to ensure file handle is fully released
        Write-Host "Copying log file: $logFile to $destLogFile"
        Copy-Item -Path $logFile -Destination $destLogFile -Force
        Write-Host "Console output log copied to: $destLogFile"
        
        # Try to remove original but don't fail if it can't be deleted
        try {
            Write-Host "Attempting to remove original log file..."
            Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
            Write-Host "Original log file removed successfully."
        } catch {
            Write-Host "Note: Original log file will be cleaned up when PowerShell session ends."
        }
    } catch {
        Write-Host "Warning: Could not copy log file to errors directory: $_"
    }
}

Write-Host "Cleanup completed. Timed out installation files have been moved to $errorsDir directory."

# Clean up access token
$tokenPath = Join-Path $PSScriptRoot "helper\tokens\access_token.txt"
if (Test-Path $tokenPath) {
    Remove-Item -Path $tokenPath -Force -ErrorAction SilentlyContinue
}

Stop-TranscriptSafely
exit 1 
#!/bin/bash

# Exit on any error
set -e

# Default values will be overridden by command line arguments
COMPONENT_TYPE=""
base_url=""
STORE_ID=""
WORKSTATION_ID=""

# Process command line options
while [ $# -gt 0 ]; do
  case "$1" in
    --ComponentType)
      COMPONENT_TYPE="$2"
      shift 2
      ;;
    --base_url)
      base_url="$2"
      shift 2
      ;;
    --StoreId)
      STORE_ID="$2"
      shift 2
      ;;
    --WorkstationId)
      WORKSTATION_ID="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      echo "Usage: $0 [--ComponentType <type>] [--base_url <url>] [--StoreId <id>] [--WorkstationId <id>]"
      exit 1
      ;;
  esac
done

# Verify all required parameters are provided
if [ -z "$COMPONENT_TYPE" ] || [ -z "$base_url" ] || [ -z "$STORE_ID" ] || [ -z "$WORKSTATION_ID" ]; then
  echo "Error: All parameters are required"
  echo "Usage: $0 --ComponentType <type> --base_url <url> --StoreId <id> --WorkstationId <id>"
  exit 1
fi

# Map ComponentType to systemName for matching in the API response
declare -A system_name_map
system_name_map["POS"]="${pos_system_type}"
system_name_map["WDM"]="${wdm_system_type}"
system_name_map["FLOW-SERVICE"]="${flow_service_system_type}"
system_name_map["LPA-SERVICE"]="${lpa_service_system_type}"
system_name_map["STOREHUB-SERVICE"]="${storehub_service_system_type}"

# Get the systemName for the current component
current_system_name="${system_name_map[$COMPONENT_TYPE]}"
if [ -z "$current_system_name" ]; then
  echo "Error: No systemName mapping found for ComponentType: $COMPONENT_TYPE"
  echo "Cannot proceed without a valid system name mapping."
  exit 1
fi

echo "Using systemName: $current_system_name for component: $COMPONENT_TYPE"

# Paths
tokens_path="$PWD/helper/tokens"

# Verify paths exist
if [ ! -d "$tokens_path" ]; then
  echo "Tokens path does not exist: $tokens_path"
  exit 1
fi

# Read the access token created by onboarding.sh
access_token_path="$tokens_path/access_token.txt"
if [ ! -f "$access_token_path" ]; then
  echo "Access token file does not exist. Please run onboarding.sh first."
  exit 1
fi

access_token=$(cat "$access_token_path")

# Common headers for all API calls
headers=(
  -H "Authorization: Bearer $access_token"
  -H "Content-Type: application/json; variant=Plain; charset=UTF-8"
  -H "Accept: application/json; variant=Plain; charset=UTF-8"
  -H "GK-Accept-Redirect: 308"
)

# Create init directory if it doesn't exist
init_path="$PWD/helper/init"
mkdir -p "$init_path"

# Get store information using get_store.json
get_store_json_path="$init_path/get_store.json"

# Skip store initialization for WDM components
if [ "$COMPONENT_TYPE" = "WDM" ]; then
  echo "Skipping store initialization for WDM component"
else
  if [ ! -f "$get_store_json_path" ]; then
    echo "Warning: get_store.json not found at: $get_store_json_path"
  else
    echo "Making API call to get store information..."
    
    # Make the API call to get store information
    store_url="https://$base_url/config-service/services/rest/infrastructure/v1/structure/child-nodes/search"
    
    # Add content-type header for this specific call
    content_type_header=(-H "Content-Type: application/json; variant=Plain; charset=UTF-8")
    
    store_response=$(curl -s -f -X POST "$store_url" "${headers[@]}" "${content_type_header[@]}" -d @"$get_store_json_path")
    
    if [ $? -eq 0 ]; then
      echo "Successfully retrieved store information"
      
      # Save the response to storemanager.json
      storemanager_path="$init_path/storemanager.json"
      echo "$store_response" > "$storemanager_path"
      echo "Store information saved to: $storemanager_path"
      
      # Extract structure unique name for the current component
      structure_unique_name=""
      if [ -f "$storemanager_path" ]; then
        # Use alternative methods if jq is not available
        if command -v jq >/dev/null 2>&1; then
          echo "JQ is available. Using JQ for structure JSON parsing."
          
          # First try to match on both system name AND workstation ID
          structure_unique_name=$(jq -r ".childNodeList[] | select(.systemName == \"$current_system_name\" and .workstationId == \"$WORKSTATION_ID\") | .structureUniqueName" "$storemanager_path")
          
          # If no match found, try to find a store-level match (no workstationId)
          if [ -z "$structure_unique_name" ]; then
            structure_unique_name=$(jq -r ".childNodeList[] | select(.systemName == \"$current_system_name\" and (has(\"workstationId\") | not or .workstationId == \"\")) | .structureUniqueName" "$storemanager_path")
            if [ -n "$structure_unique_name" ]; then
              echo "Found store-level match for $current_system_name (no workstation ID): $structure_unique_name"
            fi
          else
            echo "Found matching structure for $current_system_name with workstation ID $WORKSTATION_ID: $structure_unique_name"
          fi
        else
          echo "JQ was not detected. Falling back to bash-native JSON parsing methods."
          echo "Parsing JSON response without jq..."
          
          # First, convert the JSON to a safer format for processing
          # Convert JSON to one-object-per-line format with tr and sed
          cat "$storemanager_path" | tr -d '\n' | sed 's/},{/},\n{/g' > /tmp/flattened.json
          
          # First try to match on both system name AND workstation ID
          matching_line=$(grep "\"systemName\":\"$current_system_name\".*\"workstationId\":\"$WORKSTATION_ID\"" /tmp/flattened.json || 
                         grep "\"workstationId\":\"$WORKSTATION_ID\".*\"systemName\":\"$current_system_name\"" /tmp/flattened.json || 
                         echo "")
          
          if [ -n "$matching_line" ]; then
            # Extract the structureUniqueName from the matching line
            structure_unique_name=$(echo "$matching_line" | grep -o '"structureUniqueName":"[^"]*"' | sed 's/"structureUniqueName":"//g' | sed 's/"//g')
            echo "Found matching object with systemName: $current_system_name and workstationId: $WORKSTATION_ID"
          else
            # If no match found, try to find a store-level match (missing workstationId)
            matching_line=$(grep "\"systemName\":\"$current_system_name\"" /tmp/flattened.json | grep -v "\"workstationId\":" || echo "")
            
            if [ -n "$matching_line" ]; then
              structure_unique_name=$(echo "$matching_line" | grep -o '"structureUniqueName":"[^"]*"' | sed 's/"structureUniqueName":"//g' | sed 's/"//g')
              echo "Found store-level match for $current_system_name (no workstation ID): $structure_unique_name"
            else
              # Try another approach - extract all childNodeList content and search for systemName
              echo "No direct match found. Trying another approach..."
              # Extract content between childNodeList brackets
              sed -n '/childNodeList/,/]/p' "$storemanager_path" > /tmp/childnodes.txt
              
              # Find the line number where our system name appears
              system_line=$(grep -n "\"systemName\":\"$current_system_name\"" /tmp/childnodes.txt | cut -d: -f1)
              
              if [ -n "$system_line" ]; then
                # Extract 10 lines starting from system name line to find structureUniqueName
                structureName_line=$(tail -n +$system_line /tmp/childnodes.txt | head -10 | grep -o '"structureUniqueName":"[^"]*"' | head -1)
                if [ -n "$structureName_line" ]; then
                  structure_unique_name=$(echo "$structureName_line" | sed 's/"structureUniqueName":"//g' | sed 's/"//g')
                fi
              fi
              
              # Clean up temp files
              rm -f /tmp/childnodes.txt
            fi
            
            # Clean up temp files
            rm -f /tmp/flattened.json
          fi
          
          # Clean up temp files
          rm -f /tmp/flattened.json
        fi
        
        if [ -n "$structure_unique_name" ]; then
          echo "Found matching structure for $current_system_name: $structure_unique_name"
        else
          echo "No matching structure found for system name: $current_system_name in response"
          echo "Creating workstation through the standard flow and then refreshing structure data..."
          
          # Don't exit - allow the script to continue to the normal workstation creation section
          # After the workstation is created through the normal flow, we'll refresh the structure data
          # This will be handled automatically by the existing code
          # Just ensure we don't fail here
        fi
      else
        echo "Error: storemanager.json not found"
        echo "Cannot proceed without a valid structure pattern from the API response."
        exit 1
      fi
      
      # Save the structure unique name to a file for reference
      structure_name_path="$init_path/structure_name.txt"
      echo "$structure_unique_name" > "$structure_name_path"
      echo "Structure unique name saved to: $structure_name_path"
      
      # Check if the workstation exists for the current component
      workstation_exists=false
      
      # Check if the current component has a workstation ID in the response
      if command -v jq >/dev/null 2>&1; then
        echo "Checking for existing workstation using JQ..."
        matching_workstation=$(jq -r ".childNodeList[] | select(.systemName == \"$current_system_name\" and .workstationId == \"$WORKSTATION_ID\")" "$storemanager_path")
        if [ -n "$matching_workstation" ]; then
          workstation_exists=true
        fi
      else
        # Fallback method if jq is not available
        echo "Checking for existing workstation using bash methods..."
        if grep -q "\"systemName\":\"$current_system_name\".*\"workstationId\":\"$WORKSTATION_ID\"" "$storemanager_path" || \
           grep -q "\"workstationId\":\"$WORKSTATION_ID\".*\"systemName\":\"$current_system_name\"" "$storemanager_path"; then
          workstation_exists=true
        fi
      fi
      
      if [ "$workstation_exists" = true ]; then
        echo "Workstation $WORKSTATION_ID already exists for $current_system_name. No need to create it."
      else
        echo "Workstation $WORKSTATION_ID does not exist for $current_system_name."
        
        # Ask the user if they want to create the workstation
        read -p "Do you want to create this workstation? (y/n): " create_choice
        
        if [[ $create_choice =~ ^[Yy]$ ]]; then
          echo "Creating workstation structure..."
          
          # Path to the create structure template
          create_structure_template=""
          
          # Set the appropriate template path based on component type
          if [ "$COMPONENT_TYPE" = "POS" ]; then
            create_structure_template="$PWD/helper/structure/create_structure.json"
          elif [ "$COMPONENT_TYPE" = "WDM" ]; then
            create_structure_template="$PWD/helper/structure/create_structure.json"
          elif [ "$COMPONENT_TYPE" = "FLOW-SERVICE" ]; then
            create_structure_template="$PWD/helper/structure/create_structure.json"
          elif [ "$COMPONENT_TYPE" = "LPA-SERVICE" ]; then
            create_structure_template="$PWD/helper/structure/create_structure.json"
          elif [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ]; then
            create_structure_template="$PWD/helper/structure/create_structure.json"
          fi
          
          if [ ! -f "$create_structure_template" ]; then
            echo "Warning: Create structure template not found at: $create_structure_template"
            echo "Using default template from structure/create_structure.json"
            create_structure_template="$PWD/helper/structure/create_structure.json"
            
            # Create directories if they don't exist
            mkdir -p "$(dirname "$create_structure_template")"
            
            if [ ! -f "$create_structure_template" ]; then
              # Try in the current directory
              echo "Checking for create_structure.json in structure subdirectory..."
              if [ -f "structure/create_structure.json" ]; then
                create_structure_template="structure/create_structure.json"
                echo "Found template at: $create_structure_template"
              else
                echo "Error: Default template not found. Cannot create workstation."
                # Continue execution, don't exit
              fi
            fi
          fi
          
          if [ -f "$create_structure_template" ]; then
            # Create a temporary file with the replacements
            temp_structure_file=$(mktemp)
            
            # Determine station name based on component type
            station_name=""
            if [ "$COMPONENT_TYPE" = "POS" ]; then
              station_name="POS Client"
            elif [ "$COMPONENT_TYPE" = "WDM" ]; then
              station_name="Wall Device Manager"
            elif [ "$COMPONENT_TYPE" = "FLOW-SERVICE" ]; then
              station_name="Flow Service"
            elif [ "$COMPONENT_TYPE" = "LPA-SERVICE" ]; then
              station_name="Label Print Adapter"
            elif [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ]; then
              station_name="StoreHub"
            fi
            
            # Get tenant ID from environment or use default
            tenant_id="${tenant_id:-${tenant_id}}"
            
            # Get user ID from environment or use default
            user_id="${user_id:-1001}"
            
            # Replace placeholders in the template
            sed -e "s/@TENANT_ID@/$tenant_id/g" \
                -e "s/@RETAIL_STORE_ID@/$STORE_ID/g" \
                -e "s/@SYSTEM_TYPE@/$current_system_name/g" \
                -e "s/@WORKSTATION_ID@/$WORKSTATION_ID/g" \
                -e "s/@STATION_NAME@/$station_name/g" \
                -e "s/@USER_ID@/$user_id/g" \
                "$create_structure_template" > "$temp_structure_file"
            
            # Make the API call to create the structure
            structure_create_url="https://$base_url/config-service/services/rest/infrastructure/v1/structure/create"
            
            echo "Creating workstation using API: $structure_create_url"
            echo "Request data: $(cat "$temp_structure_file")"
            
            # Save the processed template to a file for reference
            processed_template_path="$init_path/processed_create_structure.json"
            cp "$temp_structure_file" "$processed_template_path"
            echo "Saved processed template to: $processed_template_path"
            
            structure_create_response=$(curl -s -f -X POST "$structure_create_url" "${headers[@]}" "${content_type_header[@]}" -d @"$temp_structure_file")
            
            if [ $? -eq 0 ]; then
              echo "Successfully created workstation structure"
              echo "Response: $structure_create_response"
              
              # Save the response to structure_create_response.json
              structure_create_response_path="$init_path/structure_create_response.json"
              echo "$structure_create_response" > "$structure_create_response_path"
              echo "Structure creation response saved to: $structure_create_response_path"
              
              # Add a delay to ensure configuration propagates through the system
              echo -e "\033[33mWaiting 5 seconds for workstation configuration to propagate...\033[0m"
              sleep 5
              echo -e "\033[33mContinuing after delay...\033[0m"
              
              # Refresh the structure data after creating the workstation
              echo "Refreshing structure data..."
              
              store_url="https://$base_url/config-service/services/rest/infrastructure/v1/structure/child-nodes/search"
              
              if [ -f "$get_store_json_path" ]; then
                refreshed_store_response=$(curl -s -f -X POST "$store_url" "${headers[@]}" "${content_type_header[@]}" -d @"$get_store_json_path")
                
                if [ $? -eq 0 ]; then
                  # Save the refreshed response to storemanager.json
                  echo "$refreshed_store_response" > "$storemanager_path"
                  echo "Refreshed store information saved to: $storemanager_path"
                  
                  # Look for our structure again with updated data
                  if command -v jq >/dev/null 2>&1; then
                    # Try to find the structure by system name AND workstation ID
                    structure_unique_name=$(jq -r ".childNodeList[] | select(.systemName == \"$current_system_name\" and .workstationId == \"$WORKSTATION_ID\") | .structureUniqueName" "$storemanager_path")
                    
                    if [ -n "$structure_unique_name" ]; then
                      echo "Found matching structure in refreshed data for $current_system_name with workstation ID $WORKSTATION_ID: $structure_unique_name"
                    else
                      # Try store-level match as last resort
                      structure_unique_name=$(jq -r ".childNodeList[] | select(.systemName == \"$current_system_name\" and (has(\"workstationId\") | not or .workstationId == \"\")) | .structureUniqueName" "$storemanager_path")
                      
                      if [ -n "$structure_unique_name" ]; then
                        echo "Found store-level match in refreshed data for $current_system_name: $structure_unique_name"
                      fi
                    fi
                  else
                    # Fallback for no jq - search for workstation ID
                    cat "$storemanager_path" | tr -d '\n' | sed 's/},{/},\n{/g' > /tmp/refreshed_flattened.json
                    
                    # Search for our specific workstation in updated data
                    matching_line=$(grep "\"systemName\":\"$current_system_name\".*\"workstationId\":\"$WORKSTATION_ID\"" /tmp/refreshed_flattened.json || 
                                   grep "\"workstationId\":\"$WORKSTATION_ID\".*\"systemName\":\"$current_system_name\"" /tmp/refreshed_flattened.json || 
                                   echo "")
                    
                    if [ -n "$matching_line" ]; then
                      structure_unique_name=$(echo "$matching_line" | grep -o '"structureUniqueName":"[^"]*"' | sed 's/"structureUniqueName":"//g' | sed 's/"//g')
                      echo "Found matching structure in refreshed data for $current_system_name with workstation ID $WORKSTATION_ID: $structure_unique_name"
                    else
                      # Try store-level match as last resort
                      matching_line=$(grep "\"systemName\":\"$current_system_name\"" /tmp/refreshed_flattened.json | grep -v "\"workstationId\":" || echo "")
                      
                      if [ -n "$matching_line" ]; then
                        structure_unique_name=$(echo "$matching_line" | grep -o '"structureUniqueName":"[^"]*"' | sed 's/"structureUniqueName":"//g' | sed 's/"//g')
                        echo "Found store-level match in refreshed data for $current_system_name: $structure_unique_name"
                      fi
                    fi
                    
                    # Clean up temp file
                    rm -f /tmp/refreshed_flattened.json
                  fi
                  
                  # Save the structure unique name if found
                  if [ -n "$structure_unique_name" ]; then
                    structure_name_path="$init_path/structure_name.txt"
                    echo "$structure_unique_name" > "$structure_name_path"
                    echo "Updated structure unique name saved to: $structure_name_path"
                  fi
                else
                  echo "Warning: Error refreshing structure data, continuing with existing structure data"
                fi
              else
                echo "Warning: get_store.json not found, cannot refresh structure data"
              fi
            else
              echo "Error creating workstation structure"
              echo "Response: $structure_create_response"
              # Continue execution even if this call fails
            fi
            
            # Remove the temporary file
            rm -f "$temp_structure_file"
          fi
        else
          echo "Skipping workstation creation as per user choice."
        fi
      fi
      
      # Only proceed with configuration update for StoreHub components
      if [ "$COMPONENT_TYPE" = "STOREHUB-SERVICE" ] || [ "$COMPONENT_TYPE" = "SH" ]; then
        # Now update the configuration using update_config.json from the storehub directory
        storehub_dir="$init_path/storehub"
        update_config_path="$storehub_dir/update_config.json"
        
        # Create storehub directory if it doesn't exist
        mkdir -p "$storehub_dir"
        
        if [ -f "$update_config_path" ]; then
          echo "Updating StoreHub configuration using update_config.json..."
          
          # Get hostname
          hostname=$(hostname)
          if [ -z "$hostname" ]; then
            hostname="localhost"
          fi
          
          # Get version from config
          version="v1.1.0"  # Default version
          
          # Create a temporary file for processing
          temp_file=$(mktemp)
          
          # Copy the content to the temporary file
          cp "$update_config_path" "$temp_file"
          
          # Get configuration values from environment or use defaults
          jms_port="${jms_port:-7001}"
          firebird_port="${firebird_port:-3050}"
          firebird_user="${firebird_user:-SYSDBA}"
          firebird_password="${firebird_password:-masterkey}"
          https_port="${https_port:-8543}"
          
          # Process replacements
          for placeholder_value in \
              "@STRUCTURE_UNIQUE_NAME@:$structure_unique_name" \
              "@HOSTNAME@:$hostname" \
              "@SYSTEM_NAME@:$current_system_name" \
              "@SYSTEM_VERSION@:$version" \
              "@JMS_PORT@:$jms_port" \
              "@FIREBIRD_PORT@:$firebird_port" \
              "@FIREBIRD_USER@:$firebird_user" \
              "@FIREBIRD_PASSWORD@:$firebird_password" \
              "@HTTPS_PORT@:$https_port"
          do
              placeholder=$(echo "$placeholder_value" | cut -d ":" -f 1)
              value=$(echo "$placeholder_value" | cut -d ":" -f 2-)
              
              # Using temporary files for each replacement to ensure portability
              next_temp_file=$(mktemp)
              sed "s|$placeholder|$value|g" "$temp_file" > "$next_temp_file"
              mv "$next_temp_file" "$temp_file"
          done
          
          # Move the processed file back to the original
          mv "$temp_file" "$update_config_path"
          echo "Updated update_config.json with all required values"
          
          # Save the complete request to a debug file for inspection
          debug_request_path="$storehub_dir/update_config_request_debug.json"
          cp "$update_config_path" "$debug_request_path"
          echo "Saved complete API request to: $debug_request_path"
          
          # Save detailed log of all replacements
          replacements_log_path="$storehub_dir/update_config_replacements.log"
          cat > "$replacements_log_path" << EOL
=== Configuration Request Details ===
Timestamp: $(date)
API URL: https://$base_url/config-service/services/rest/config-management/v1/parameter-contents/plain
Content-Type: application/json; variant=Plain; charset=UTF-8

=== Replacements Applied ===
@STRUCTURE_UNIQUE_NAME@ = $structure_unique_name
@HOSTNAME@ = $hostname
@SYSTEM_NAME@ = $current_system_name
@SYSTEM_VERSION@ = $version
@JMS_PORT@ = $jms_port
@FIREBIRD_PORT@ = $firebird_port
@FIREBIRD_USER@ = $firebird_user
@FIREBIRD_PASSWORD@ = $firebird_password
@HTTPS_PORT@ = $https_port

=== Request Headers ===
Authorization: Bearer $access_token
Content-Type: application/json; variant=Plain; charset=UTF-8
Accept: application/json; variant=Plain; charset=UTF-8
GK-Accept-Redirect: 308

=== Full Request Body ===
$(cat "$update_config_path")
EOL
          echo "Saved replacements log to: $replacements_log_path"
          
          # Now display the updated content for debugging
          echo -e "\n====== API CALL DETAILS ======"
          
          # Make the API call to update the configuration
          config_url="https://$base_url/config-service/services/rest/config-management/v1/parameter-contents/plain"
          
          # Capture full response with headers to a file for debugging
          curl_debug_log="$storehub_dir/curl_debug.log"
          curl_verbose_log="$storehub_dir/curl_verbose.log"
          
          # Save the exact curl command to a file for manual testing
          curl_command_path="$storehub_dir/curl_command.sh"
          cat > "$curl_command_path" << 'EOL'
#!/bin/bash
# Exact curl command for manual testing

# The exact API endpoint
CONFIG_URL="$config_url"

# The access token 
ACCESS_TOKEN="$access_token"

# Save a copy of the JSON data
# Using a heredoc for better handling of special characters
cat > update_config_copy.json << 'JSON_DATA'
EOL

          # Append the actual JSON content to the file
          cat "$update_config_path" >> "$curl_command_path" 

          # Add the rest of the script
          cat >> "$curl_command_path" << 'EOL'
JSON_DATA

echo "=== Running curl command with update_config_copy.json ==="
echo "URL: $CONFIG_URL"
echo "Auth token is available in \$ACCESS_TOKEN"
echo "JSON content saved to update_config_copy.json"

echo -e "\nRunning API call..."
curl -v -X POST "$CONFIG_URL" \
  -H "Authorization: Bearer $ACCESS_TOKEN" \
  -H "Content-Type: application/json; variant=Plain; charset=UTF-8" \
  -H "Accept: application/json; variant=Plain; charset=UTF-8" \
  -H "GK-Accept-Redirect: 308" \
  -d @update_config_copy.json

# Exit status
echo -e "\nCurl exit status: $?"
EOL

          # Fix variables in the script we just created by replacing placeholders
          sed -i.bak "s|\\\$config_url|$config_url|g" "$curl_command_path"
          sed -i.bak "s|\\\$access_token|$access_token|g" "$curl_command_path"
          rm -f "${curl_command_path}.bak"
          
          chmod +x "$curl_command_path"
          echo "Saved executable curl command to: $curl_command_path for manual testing"
          
          # Save the complete request with all headers and actual data to a file for inspection
          curl_full_request_path="$storehub_dir/curl_full_request.txt"
          cat > "$curl_full_request_path" << EOL
=== FULL CURL REQUEST DETAILS ===
URL: $config_url
METHOD: POST

=== HEADERS ===
Authorization: Bearer $access_token
Content-Type: application/json; variant=Plain; charset=UTF-8
Accept: application/json; variant=Plain; charset=UTF-8
GK-Accept-Redirect: 308

=== REQUEST BODY ===
$(cat "$update_config_path")
EOL
          echo "Saved full request details to: $curl_full_request_path"
          
          # Make API call with verbose output to separate log
          echo "Making API call with verbose output saved to $curl_verbose_log"
          curl -v -X POST "$config_url" "${headers[@]}" "${content_type_header[@]}" -d @"$update_config_path" > "$curl_debug_log" 2> "$curl_verbose_log"
          
          # Save exit code
          curl_exit=$?
          
          # Make the actual API call
          config_response=$(curl -s -X POST "$config_url" "${headers[@]}" "${content_type_header[@]}" -d @"$update_config_path")
          
          if [ $? -eq 0 ] && [ $curl_exit -eq 0 ]; then
            echo "Successfully updated configuration"
            echo "Verbose curl logs saved to: $curl_verbose_log"
            
            # Save the response to config_response.json
            config_response_path="$storehub_dir/config_response.json"
            echo "$config_response" > "$config_response_path"
            echo "Configuration response saved to: $config_response_path"
            
            # Save a raw response for debugging
            raw_response_path="$storehub_dir/config_response_raw.txt"
            echo "$config_response" > "$raw_response_path"
            echo "Raw API response saved to: $raw_response_path"
          else
            echo "Error updating configuration"
            echo "Response: $config_response"
            # Continue execution even if this call fails
          fi
        else
          echo "Warning: StoreHub update_config.json not found at: $update_config_path"
        fi
      else
        echo "Skipping configuration update - not a StoreHub component"
      fi
    else
      echo "Error retrieving store information"
      echo "Response: $store_response"
      # Continue execution even if this call fails
    fi
  fi
fi

# First API call - Get Business Unit
bu_url="https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/business-units/$STORE_ID"
bu_response=$(curl -s -f -X GET "$bu_url" "${headers[@]}")
if [ $? -ne 0 ]; then
  echo "Error occurred during business unit API call"
  exit 1
fi

echo "Successfully retrieved business unit information"

# Parse the business unit response for businessUnitGroupID from the key object
if command -v jq >/dev/null 2>&1; then
  # Use jq if available
  echo "JQ is available. Using JQ for JSON parsing."
  business_unit_group_id=$(echo "$bu_response" | jq -r '.key.businessUnitGroupID // empty')
else
  # Improved fallback that handles nested JSON more reliably
  echo "JQ was not detected. Falling back to bash-native JSON parsing methods."
  # First normalize the JSON by removing newlines and unnecessary spaces
  normalized_json=$(echo "$bu_response" | tr -d '\n' | sed 's/  */ /g')
  
  # Extract the businessUnitGroupID
  if echo "$normalized_json" | grep -q '"key".*"businessUnitGroupID"'; then
    # Match the pattern inside the key section
    business_unit_group_id=$(echo "$normalized_json" | grep -o '"businessUnitGroupID":"[^"]*"' | head -1 | sed 's/"businessUnitGroupID":"//g' | sed 's/"//g')
  fi
  
  # If that fails, try a more general pattern
  if [ -z "$business_unit_group_id" ]; then
    business_unit_group_id=$(echo "$normalized_json" | grep -o '"businessUnitGroupID"[[:space:]]*:[[:space:]]*"[^"]*"' | head -1 | sed 's/.*"businessUnitGroupID"[[:space:]]*:[[:space:]]*"//g' | sed 's/".*//g')
  fi
fi

if [ -z "$business_unit_group_id" ]; then
  echo "Failed to get businessUnitGroupID from response:"
  echo "Response excerpt (first 200 characters):"
  echo "$bu_response" | head -c 200
  echo "..."
  exit 1
fi

echo "Found businessUnitGroupID: $business_unit_group_id"

# Second API call - Try to Get Workstation first
ws_url="https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/workstations/(businessUnitGroupId=$business_unit_group_id,workstationId=$WORKSTATION_ID)"
ws_response=$(curl -s -f -X GET "$ws_url" "${headers[@]}" || echo "HTTP_ERROR")

if [ "$ws_response" = "HTTP_ERROR" ]; then
  # Check if it's a 404 error
  status_code=$(curl -s -o /dev/null -w "%{http_code}" "$ws_url" "${headers[@]}")
  
  if [ "$status_code" = "404" ]; then
    echo "Workstation not found, creating new workstation..."
    
    # Determine workstation type based on ComponentType
    case "$COMPONENT_TYPE" in
      'LPA-SERVICE')
        type_code="LPAS"
        ;;
      'STOREHUB-SERVICE')
        type_code="SHS"
        ;;
      'FLOW-SERVICE')
        type_code="EDGE"
        ;;
      'POS')
        type_code="POS"
        ;;
      'WDM')
        type_code="EDGE"
        ;;
      *)
        type_code="POS"
        ;;
    esac

    # Create workstation payload
    current_time=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")
    ws_payload="{\"workstation\":{\"key\":{\"workstationID\":\"$WORKSTATION_ID\",\"businessUnitGroupID\":\"$business_unit_group_id\"},\"typeCode\":\"$type_code\",\"createTimestampUTC0\":\"$current_time\"}}"
    
    ws_create_url="https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/workstations"
    ws_response=$(curl -s -f -X POST "$ws_create_url" "${headers[@]}" -d "$ws_payload")
    
    if [ $? -ne 0 ]; then
      echo "Error creating workstation"
      echo "Response: $ws_response"
      exit 1
    fi
    echo "Successfully created new workstation"
  else
    echo "Error accessing workstation. Status code: $status_code"
    echo "Response: $ws_response"
    exit 1
  fi
else
  echo "Successfully retrieved existing workstation information"
fi

# Save responses to files
echo "$bu_response" > "business-unit.json"
echo "$ws_response" > "workstation.json"
echo "Saved response data to business-unit.json and workstation.json"

# Exit successfully
exit 0 
param (
    [Parameter(Mandatory=$true)]
    [string]$ComponentType,
    [Parameter(Mandatory=$true)]
    [string]$base_url,
    [Parameter(Mandatory=$true)]
    [string]$StoreId,
    [Parameter(Mandatory=$true)]
    [string]$WorkstationId
)

# Get script directory and set current directory as base path
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$basePath = Get-Location

# Paths
$tokensPath = Join-Path $PSScriptRoot "helper\tokens"

# Verify paths exist
if (-Not (Test-Path $tokensPath)) {
    Write-Host "Tokens path does not exist: $tokensPath"
    exit 1
}

# Read the access token created by onboarding.ps1
$accessTokenPath = Join-Path $tokensPath "access_token.txt"
if (-Not (Test-Path $accessTokenPath)) {
    Write-Host "Access token file does not exist. Please run onboarding.ps1 first."
    exit 1
}

$accessToken = Get-Content -Path $accessTokenPath -Raw

# Common headers for all API calls
$headers = @{
    "Authorization" = "Bearer $accessToken"
    "Content-Type" = "application/json; variant=Plain; charset=UTF-8"
    "Accept" = "application/json; variant=Plain; charset=UTF-8"
    "GK-Accept-Redirect" = "308"
}

# Map ComponentType to systemName for matching in the API response
$systemNameMap = @{
    'POS' = '${pos_system_type}'
    'WDM' = '${wdm_system_type}'
    'FLOW-SERVICE' = '${flow_service_system_type}'
    'LPA-SERVICE' = '${lpa_service_system_type}'
    'STOREHUB-SERVICE' = '${storehub_service_system_type}'
}

# Get the systemName for the current component
$currentSystemName = $systemNameMap[$ComponentType]
if (-Not $currentSystemName) {
    Write-Host "Error: No systemName mapping found for ComponentType: $ComponentType"
    Write-Host "Cannot proceed without a valid system name mapping."
    exit 1
}

Write-Host "Using systemName: $currentSystemName for component: $ComponentType"

try {
    # Create init directory if it doesn't exist
    $initPath = Join-Path $PSScriptRoot "helper\init"
    if (-Not (Test-Path $initPath)) {
        New-Item -ItemType Directory -Path $initPath -Force | Out-Null
        Write-Host "Created init directory: $initPath"
    }
    
    # Get store information using get_store.json
    $getStoreJsonPath = Join-Path $initPath "get_store.json"
    
    # Skip store initialization for WDM components
    if ($ComponentType -eq "WDM") {
        Write-Host "Skipping store initialization for WDM component"
    } else {
        if (-Not (Test-Path $getStoreJsonPath)) {
            Write-Host "Warning: get_store.json not found at: $getStoreJsonPath"
        } else {
            Write-Host "Making API call to get store information..."
            
            # Read the get_store.json file
            $getStoreJson = Get-Content -Path $getStoreJsonPath -Raw
            
            # Make the API call to get store information
            $storeUrl = "https://$base_url/config-service/services/rest/infrastructure/v1/structure/child-nodes/search"
            
            try {
                $storeResponse = Invoke-RestMethod -Uri $storeUrl -Method Post -Headers $headers -Body $getStoreJson -ContentType "application/json; variant=Plain; charset=UTF-8"
                Write-Host "Successfully retrieved store information"
                
                # Save the response to storemanager.json
                $storemanagerPath = Join-Path $initPath "storemanager.json"
                $storeResponse | ConvertTo-Json -Depth 10 | Set-Content -Path $storemanagerPath -NoNewline
                Write-Host "Store information saved to: $storemanagerPath"
                
                # Extract structure unique name for the current component
                $structureUniqueName = ""
                if (Test-Path $storemanagerPath) {
                    try {
                        $storeManagerData = Get-Content -Path $storemanagerPath -Raw | ConvertFrom-Json
                        
                        # Look for the structure that matches our system name AND workstation ID
                        foreach ($item in $storeManagerData.childNodeList) {
                            if ($item.systemName -eq $currentSystemName -and $item.workstationId -eq $WorkstationId) {
                                $structureUniqueName = $item.structureUniqueName
                                Write-Host "Found matching structure for ${currentSystemName} with workstation ID ${WorkstationId}: $structureUniqueName"
                                break
                            }
                        }
                        
                        # If no matching workstation is found, check if we have a store-level match (for initial setup)
                        if ([string]::IsNullOrEmpty($structureUniqueName)) {
                            foreach ($item in $storeManagerData.childNodeList) {
                                if ($item.systemName -eq $currentSystemName -and (-not $item.PSObject.Properties.Name.Contains("workstationId") -or [string]::IsNullOrEmpty($item.workstationId))) {
                                    $structureUniqueName = $item.structureUniqueName
                                    Write-Host "Found store-level match for ${currentSystemName} (no workstation ID): $structureUniqueName"
                                    # Don't break here, continue searching for better matches
                                }
                            }
                        }
                        
                        if ([string]::IsNullOrEmpty($structureUniqueName)) {
                            Write-Host "No matching structure found for system name: $currentSystemName with workstation ID: $WorkstationId"
                            Write-Host "Creating workstation through the standard flow and then refreshing structure data..."
                            
                            # Don't exit - allow the script to continue to the normal workstation creation section
                            # After the workstation is created through the normal flow, we'll refresh the structure data
                            # This will be handled automatically by the existing code
                            # Just ensure we don't fail here
                        }
                    } catch {
                        Write-Host "Error parsing storemanager.json: $_"
                        Write-Host "Cannot proceed without a valid structure pattern from the API response."
                        exit 1
                    }
                } else {
                    Write-Host "Error: storemanager.json not found"
                    Write-Host "Cannot proceed without a valid structure pattern from the API response."
                    exit 1
                }
                
                # Save the structure unique name to a file for reference
                $structureNamePath = Join-Path $initPath "structure_name.txt"
                $structureUniqueName | Set-Content -Path $structureNamePath -NoNewline
                Write-Host "Structure unique name saved to: $structureNamePath"
                
                # Check if the workstation exists for the current component
                $workstationExists = $false
                
                # Check if the current component has a workstation ID in the response
                foreach ($item in $storeManagerData.childNodeList) {
                    if ($item.systemName -eq $currentSystemName -and $item.workstationId -eq $WorkstationId) {
                        $workstationExists = $true
                        Write-Host "Found existing workstation: $WorkstationId for $currentSystemName"
                        break
                    }
                }
                
                if ($workstationExists) {
                    Write-Host "Workstation $WorkstationId already exists for $currentSystemName. No need to create it."
                } else {
                    Write-Host "Workstation $WorkstationId does not exist for $currentSystemName."
                    
                    # Ask the user if they want to create the workstation
                    $createChoice = Read-Host "Do you want to create this workstation? (y/n)"
                    
                    if ($createChoice -match "^[Yy]$") {
                        Write-Host "Creating workstation structure..."
                        
                        # Path to the create structure template
                        $createStructureTemplate = ""
                        
                        # Set the appropriate template path based on component type
                        switch ($ComponentType) {
                            'POS' { $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json" }
                            'WDM' { $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json" }
                            'FLOW-SERVICE' { $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json" }
                            'LPA-SERVICE' { $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json" }
                            'STOREHUB-SERVICE' { $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json" }
                        }
                        
                        if (-Not (Test-Path $createStructureTemplate)) {
                            Write-Host "Warning: Create structure template not found at: $createStructureTemplate"
                            Write-Host "Using default template from structure/create_structure.json"
                            $createStructureTemplate = Join-Path $basePath "helper\structure\create_structure.json"
                            
                            # Create directories if they don't exist
                            $createStructureDir = Split-Path -Parent $createStructureTemplate
                            if (-Not (Test-Path $createStructureDir)) {
                                New-Item -ItemType Directory -Path $createStructureDir -Force | Out-Null
                                Write-Host "Created directory: $createStructureDir"
                            }
                            
                            if (-Not (Test-Path $createStructureTemplate)) {
                                # Try in the current directory
                                Write-Host "Checking for create_structure.json in structure subdirectory..."
                                $flatPathTemplate = Join-Path (Get-Location) "structure\create_structure.json"
                                if (Test-Path $flatPathTemplate) {
                                    $createStructureTemplate = $flatPathTemplate
                                    Write-Host "Found template at: $createStructureTemplate"
                                } else {
                                    Write-Host "Error: Default template not found. Cannot create workstation."
                                    # Continue execution, don't exit
                                }
                            }
                        }
                        
                        if (Test-Path $createStructureTemplate) {
                            # Read the create_structure.json template
                            $createStructureJson = Get-Content -Path $createStructureTemplate -Raw
                            
                            # Determine station name based on component type
                            $stationName = switch ($ComponentType) {
                                'POS' { "POS Client" }
                                'WDM' { "Wall Device Manager" }
                                'FLOW-SERVICE' { "Flow Service" }
                                'LPA-SERVICE' { "Label Print Adapter" }
                                'STOREHUB-SERVICE' { "StoreHub" }
                                default { "POS Client" }
                            }
                            
                            # Get tenant ID from environment or use default
                            $tenantId = if ($env:tenant_id) { $env:tenant_id } else { "${tenant_id}" }
                            
                            # Get user ID from environment or use default
                            $userId = if ($env:user_id) { $env:user_id } else { "${user_id}" }
                            
                            # Replace placeholders in the template
                            $createStructureJson = $createStructureJson -replace '@TENANT_ID@', $tenantId
                            $createStructureJson = $createStructureJson -replace '@RETAIL_STORE_ID@', $StoreId
                            $createStructureJson = $createStructureJson -replace '@SYSTEM_TYPE@', $currentSystemName
                            $createStructureJson = $createStructureJson -replace '@WORKSTATION_ID@', $WorkstationId
                            $createStructureJson = $createStructureJson -replace '@STATION_NAME@', $stationName
                            $createStructureJson = $createStructureJson -replace '@USER_ID@', $userId
                            
                            # Make the API call to create the structure
                            $structureCreateUrl = "https://$base_url/config-service/services/rest/infrastructure/v1/structure/create"
                            
                            Write-Host "Creating workstation using API: $structureCreateUrl"
                            
                            try {
                                $structureCreateResponse = Invoke-RestMethod -Uri $structureCreateUrl -Method Post -Headers $headers -Body $createStructureJson -ContentType "application/json; variant=Plain; charset=UTF-8"
                                Write-Host "Successfully created workstation structure"
                                
                                # Add a delay to ensure configuration propagates through the system
                                Write-Host "Waiting 30 seconds for configuration to propagate..." -ForegroundColor Yellow
                                Start-Sleep -Seconds 30
                                Write-Host "Continuing after delay..." -ForegroundColor Yellow
                                
                                # Refresh the structure data after creating the workstation
                                Write-Host "Refreshing structure data..."
                                
                                $storeUrl = "https://$base_url/config-service/services/rest/infrastructure/v1/structure/child-nodes/search"
                                $getStoreJson = Get-Content -Path $getStoreJsonPath -Raw
                                
                                try {
                                    $refreshedStoreResponse = Invoke-RestMethod -Uri $storeUrl -Method Post -Headers $headers -Body $getStoreJson -ContentType "application/json; variant=Plain; charset=UTF-8"
                                    
                                    # Save the refreshed response to storemanager.json
                                    $refreshedStoreResponse | ConvertTo-Json -Depth 10 | Set-Content -Path $storemanagerPath -NoNewline
                                    Write-Host "Refreshed store information saved to: $storemanagerPath"
                                    
                                    # Look for our structure again with updated data
                                    $refreshedStoreManagerData = Get-Content -Path $storemanagerPath -Raw | ConvertFrom-Json
                                    
                                    # Try to find the structure by system name AND workstation ID
                                    foreach ($item in $refreshedStoreManagerData.childNodeList) {
                                        if ($item.systemName -eq $currentSystemName -and $item.workstationId -eq $WorkstationId) {
                                            $structureUniqueName = $item.structureUniqueName
                                            Write-Host "Found matching structure in refreshed data for ${currentSystemName} with workstation ID ${WorkstationId}: $structureUniqueName"
                                            break
                                        }
                                    }
                                    
                                    # If still not found, add fallback checks
                                    if ([string]::IsNullOrEmpty($structureUniqueName)) {
                                        Write-Host "Structure not found in refreshed data. Looking for fallbacks..."
                                        
                                        # Try store-level match as last resort
                                        foreach ($item in $refreshedStoreManagerData.childNodeList) {
                                            if ($item.systemName -eq $currentSystemName -and (-not $item.PSObject.Properties.Name.Contains("workstationId") -or [string]::IsNullOrEmpty($item.workstationId))) {
                                                $structureUniqueName = $item.structureUniqueName
                                                Write-Host "Found store-level match in refreshed data for ${currentSystemName}: $structureUniqueName"
                                                break
                                            }
                                        }
                                    }
                                    
                                    # Save the structure unique name if found
                                    if (-not [string]::IsNullOrEmpty($structureUniqueName)) {
                                        $structureNamePath = Join-Path $initPath "structure_name.txt"
                                        $structureUniqueName | Set-Content -Path $structureNamePath -NoNewline
                                        Write-Host "Updated structure unique name saved to: $structureNamePath"
                                    }
                                }
                                catch {
                                    Write-Host "Warning: Error refreshing structure data: $_"
                                    # Continue anyway, as this is just a refresh attempt
                                }
                            } catch {
                                Write-Host "Error creating workstation structure: $_"
                                if ($_.Exception.Response) {
                                    $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                                    $reader.BaseStream.Position = 0
                                    $reader.DiscardBufferedData()
                                    $responseBody = $reader.ReadToEnd()
                                    Write-Host "Response body: $responseBody"
                                }
                                # Continue execution even if this call fails
                            }
                        }
                    } else {
                        Write-Host "Skipping workstation creation as per user choice."
                    }
                }
                
                # Only proceed with configuration update for StoreHub components
                if ($ComponentType -eq 'STOREHUB-SERVICE' -or $ComponentType -eq 'SH') {
                    # Now update the configuration using update_config.json from the storehub directory
                    $storehubDir = Join-Path $initPath "storehub"
                    $updateConfigPath = Join-Path $storehubDir "update_config.json"
                    
                    if (Test-Path $updateConfigPath) {
                        Write-Host "Updating StoreHub configuration using update_config.json..."
                        
                        # Read the update_config.json template
                        $updateConfigJson = Get-Content -Path $updateConfigPath -Raw
                        
                        # Get hostname
                        $hostname = $env:COMPUTERNAME
                        if ([string]::IsNullOrEmpty($hostname)) {
                            $hostname = "localhost"
                        }
                        
                        # Get version from config
                        $version = "v1.1.0"  # Default version
                        
                        # Replace placeholders in the template
                        $updateConfigJson = $updateConfigJson -replace '@STRUCTURE_UNIQUE_NAME@', $structureUniqueName
                        $updateConfigJson = $updateConfigJson -replace '@HOSTNAME@', $hostname
                        
                        # Additional replacements for other placeholders
                        $updateConfigJson = $updateConfigJson -replace '@SYSTEM_NAME@', $currentSystemName
                        $updateConfigJson = $updateConfigJson -replace '@SYSTEM_VERSION@', $version
                        
                        # Get configuration values from environment or use defaults
                        $jmsPort = if ($env:jms_port) { $env:jms_port } else { "7001" }
                        $firebirdPort = if ($env:firebird_port) { $env:firebird_port } else { "3050" }
                        $firebirdUser = if ($env:firebird_user) { $env:firebird_user } else { "SYSDBA" }
                        $firebirdPassword = if ($env:firebird_password) { $env:firebird_password } else { "masterkey" }
                        $httpsPort = if ($env:https_port) { $env:https_port } else { "8543" }
                        
                        # Replace the remaining placeholders
                        $updateConfigJson = $updateConfigJson -replace '@JMS_PORT@', $jmsPort
                        $updateConfigJson = $updateConfigJson -replace '@FIREBIRD_PORT@', $firebirdPort
                        $updateConfigJson = $updateConfigJson -replace '@FIREBIRD_USER@', $firebirdUser
                        $updateConfigJson = $updateConfigJson -replace '@FIREBIRD_PASSWORD@', $firebirdPassword
                        $updateConfigJson = $updateConfigJson -replace '@HTTPS_PORT@', $httpsPort
                        
                        # Write the updated content back to the file
                        $updateConfigJson | Set-Content -Path $updateConfigPath -NoNewline
                        Write-Host "Updated update_config.json with all required values"
                        
                        # Make the API call to update the configuration
                        $configUrl = "https://$base_url/config-service/services/rest/config-management/v1/parameter-contents/plain"
                        
                        try {
                            # Read the modified content from the file to ensure we're using the updated content
                            $modifiedUpdateConfigJson = Get-Content -Path $updateConfigPath -Raw
                            
                            # Verbose debug output
                            Write-Host "`nAPI CALL DETAILS:" -ForegroundColor Cyan
                            Write-Host "URL: $configUrl" -ForegroundColor Cyan
                            Write-Host "JMS Port: $jmsPort" -ForegroundColor Cyan
                            Write-Host "Firebird Port: $firebirdPort" -ForegroundColor Cyan
                            Write-Host "Firebird User: $firebirdUser" -ForegroundColor Cyan
                            Write-Host "Firebird Password: [not shown]" -ForegroundColor Cyan
                            Write-Host "HTTPS Port: $httpsPort" -ForegroundColor Cyan
                            Write-Host "Structure Unique Name: $structureUniqueName" -ForegroundColor Cyan
                            Write-Host "Hostname: $hostname" -ForegroundColor Cyan
                            Write-Host "System Name: $currentSystemName" -ForegroundColor Cyan
                            Write-Host "System Version: $version" -ForegroundColor Cyan
                            Write-Host "`nActual Request Content:" -ForegroundColor Green
                            
                            # Show the request content but mask the password
                            $displayJson = $modifiedUpdateConfigJson -replace '"ds-embedded.datasource.password_encrypted",\s*"value":\s*"[^"]*"', '"ds-embedded.datasource.password_encrypted", "value": "[not shown]"'
                            Write-Host $displayJson -ForegroundColor Green
                            Write-Host "`n"
                            
                            # Make the API call with the JSON content directly
                            $configResponse = Invoke-RestMethod -Uri $configUrl -Method Post -Headers $headers -Body $modifiedUpdateConfigJson -ContentType "application/json; variant=Plain; charset=UTF-8"
                            Write-Host "Successfully updated StoreHub configuration"
                            
                        } catch {
                            Write-Host "Error updating StoreHub configuration: $_" -ForegroundColor Red
                            if ($_.Exception.Response) {
                                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                                $reader.BaseStream.Position = 0
                                $reader.DiscardBufferedData()
                                $responseBody = $reader.ReadToEnd()
                                Write-Host "Response body: $responseBody" -ForegroundColor Red
                            }
                            # Continue execution even if this call fails
                        }
                    } else {
                        Write-Host "Warning: StoreHub update_config.json not found at: $updateConfigPath"
                    }
                } else {
                    Write-Host "Skipping configuration update - not a StoreHub component"
                }
            } catch {
                Write-Host "Error retrieving store information: $_"
                if ($_.Exception.Response) {
                    $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                    $reader.BaseStream.Position = 0
                    $reader.DiscardBufferedData()
                    $responseBody = $reader.ReadToEnd()
                    Write-Host "Response body: $responseBody"
                }
                # Continue execution even if this call fails
            }
        }
    }

    # First API call - Get Business Unit
    $buUrl = "https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/business-units/$StoreId"
    $buResponse = Invoke-RestMethod -Uri $buUrl -Method Get -Headers $headers
    Write-Host "Successfully retrieved business unit information"
    
    # Extract businessUnitGroupID from the key object in the response
    $businessUnitGroupId = $buResponse.key.businessUnitGroupID
    
    if (-Not $businessUnitGroupId) {
        Write-Host "Failed to get businessUnitGroupID from response"
        Write-Host "Response content:"
        Write-Host ($buResponse | ConvertTo-Json -Depth 10)
        exit 1
    }

    Write-Host "Found businessUnitGroupID: $businessUnitGroupId"

    # Second API call - Try to Get Workstation first
    $wsUrl = "https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/workstations/(businessUnitGroupId=$businessUnitGroupId,workstationId=$WorkstationId)"
    try {
        $wsResponse = Invoke-RestMethod -Uri $wsUrl -Method Get -Headers $headers
        Write-Host "Successfully retrieved existing workstation information"
    }
    catch {
        if ($_.Exception.Response.StatusCode.value__ -eq 404) {
            Write-Host "Workstation not found, creating new workstation..."
            
            # Determine workstation type based on ComponentType
            $typeCode = switch ($ComponentType) {
                'LPA-SERVICE' { 'LPAS' }
                'STOREHUB-SERVICE' { 'SHS' }
                'FLOW-SERVICE' { 'EDGE' }
                'POS' { 'POS' }
                'WDM' { 'EDGE' }
                default { 'POS' }
            }

            # Create workstation payload
            $wsCreateUrl = "https://$base_url/swee-sdc/tenants/${tenant_id}/services/rest/master-data/v1/workstations"
            $wsPayload = @{
                workstation = @{
                    key = @{
                        workstationID = $WorkstationId
                        businessUnitGroupID = $businessUnitGroupId
                    }
                    typeCode = $typeCode
                    createTimestampUTC0 = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
                }
            } | ConvertTo-Json -Depth 10

            $wsResponse = Invoke-RestMethod -Uri $wsCreateUrl -Method Post -Headers $headers -Body $wsPayload
            Write-Host "Successfully created new workstation"
            
            # Add a delay to ensure configuration propagates through the system
            Write-Host "Waiting 30 seconds for workstation configuration to propagate..." -ForegroundColor Yellow
            Start-Sleep -Seconds 30
            Write-Host "Continuing after delay..." -ForegroundColor Yellow
        }
        else {
            Write-Host "Error accessing workstation:"
            Write-Host $_
            if ($_.Exception.Response) {
                $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
                $reader.BaseStream.Position = 0
                $reader.DiscardBufferedData()
                $responseBody = $reader.ReadToEnd()
                Write-Host "Response body: $responseBody"
            }
            exit 1
        }
    }

    # Save responses to files for reference
    $buResponse | ConvertTo-Json -Depth 10 | Set-Content -Path "business-unit.json" -NoNewline
    $wsResponse | ConvertTo-Json -Depth 10 | Set-Content -Path "workstation.json" -NoNewline
    Write-Host "Saved response data to business-unit.json and workstation.json"

    # Explicitly return success
    exit 0
}
catch {
    Write-Host "Error occurred: $_" -ForegroundColor Red
    if ($_.Exception.Response) {
        $reader = New-Object System.IO.StreamReader($_.Exception.Response.GetResponseStream())
        $reader.BaseStream.Position = 0
        $reader.DiscardBufferedData()
        $responseBody = $reader.ReadToEnd()
        Write-Host "Response body: $responseBody" -ForegroundColor Red
    }
    exit 1
} 